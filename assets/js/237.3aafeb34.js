(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{555:function(t,a,s){"use strict";s.r(a);var r=s(3),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("当一个程序启动的时候，会发生下面的步骤：")]),t._v(" "),a("ul",[a("li",[t._v("JavaScript创建一个新的执行上下文，我们叫作本地执行上下文。")]),t._v(" "),a("li",[t._v("这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。")]),t._v(" "),a("li",[t._v("新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。")])]),t._v(" "),a("p",[t._v("函数结束时，会发生以下情况:")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("这个本地执行上下文从执行堆栈中弹出。")])]),t._v(" "),a("li",[a("p",[t._v("函数将返回值返回调用上下文。调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined。")])]),t._v(" "),a("li",[a("p",[t._v("这个本地执行上下文被销毁，销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。")])])]),t._v(" "),a("h3",{attrs:{id:"基础示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础示例"}},[t._v("#")]),t._v(" 基础示例")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTwo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" ret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" ret\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTwo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[a("strong",[t._v("执行过程分析")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("在第1行，我们在全局执行上下文中声明了一个新变量a，并将赋值为3。")])]),t._v(" "),a("li",[a("p",[t._v("接下来就变得棘手了，第2行到第5行实际上是在一起的。这里发生了什么? 我们在全局执行上下文中声明了一个名为addTwo的新变量,我们给它分配了什么?一个函数定义。两个括号{}之间的任何内容都被分配给addTwo，函数内部的代码没有被求值，没有被执行，只是存储在一个变量中以备将来使用。")])]),t._v(" "),a("li",[a("p",[t._v("现在我们在第6行。它看起来很简单，但是这里有很多东西需要拆开分析。首先，我们在全局执行上下文中声明一个新变量，并将其标记为b，变量一经声明，其值即为undefined。")])]),t._v(" "),a("li",[a("p",[t._v("接下来，仍然在第6行，我们看到一个赋值操作符。我们准备给变量b赋一个新值，接下来我们看到一个函数被调用。当看到一个变量后面跟着一个圆括号(…)时，这就是调用函数的信号，接着，每个函数都返回一些东西(值、对象或 undefined)，无论从函数返回什么，都将赋值给变量b。")])]),t._v(" "),a("li",[a("p",[t._v("但是首先我们需要调用addTwo的函数。JavaScript将在其全局执行上下文内存中查找名为addTwo的变量。噢，它找到了一个，它是在步骤2(或第2 - 5行)中定义的。变量add2包含一个函数定义。注意，变量a作为参数传递给函数。JavaScript在全局执行上下文内存中搜索变量a，找到它，发现它的值是3，并将数字3作为参数传递给函数，准备好执行函数。")])]),t._v(" "),a("li",[a("p",[t._v("现在执行上下文将切换,创建了一个新的本地执行上下文，我们将其命名为“addTwo执行上下文”，执行上下文被推送到调用堆栈上。在addTwo执行上下文中，我们要做的第一件事是什么?")])]),t._v(" "),a("li",[a("p",[t._v("你可能会说，“在addTwo执行上下文中声明了一个新的变量ret”，这是不对的。正确的答案是，我们需要先看函数的参数。在addTwo执行上下文中声明一个新的变量``x```，因为值3是作为参数传递的，所以变量x被赋值为3。")])]),t._v(" "),a("li",[a("p",[t._v("下一步是:在addTwo执行上下文中声明一个新的变量ret。它的值被设置为 undefined(第三行)。")])]),t._v(" "),a("li",[a("p",[t._v("仍然是第3行，需要执行一个相加操作。首先我们需要x的值，JavaScript会寻找一个变量x，它会首先在addTwo执行上下文中寻找，找到了一个值为3。第二个操作数是数字2。两个相加结果为5就被分配给变量ret。")])]),t._v(" "),a("li",[a("p",[t._v("第4行，我们返回变量ret的内容，在addTwo执行上下文中查找，找到值为5，返回，函数结束。")])]),t._v(" "),a("li",[a("p",[t._v("第4-5行，函数结束。addTwo执行上下文被销毁，变量x和ret被释放，它们已经不存在了。addTwo 执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数addTwo是从全局执行上下文调用的。")])]),t._v(" "),a("li",[a("p",[t._v("现在我们继续第4步的内容，返回值5被分配给变量b，程序仍然在第6行。")])]),t._v(" "),a("li",[a("p",[t._v("在第7行，b的值 5 被打印到控制台了。")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);