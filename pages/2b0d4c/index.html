<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>15 offer收割机之React篇(上) | 朽木学社</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.94e8daa7.css" as="style"><link rel="preload" href="/assets/js/app.fb1f9387.js" as="script"><link rel="preload" href="/assets/js/2.3389238a.js" as="script"><link rel="preload" href="/assets/js/149.ed205a73.js" as="script"><link rel="prefetch" href="/assets/js/10.3ee11414.js"><link rel="prefetch" href="/assets/js/100.6630a2d2.js"><link rel="prefetch" href="/assets/js/101.92d97350.js"><link rel="prefetch" href="/assets/js/102.633f7606.js"><link rel="prefetch" href="/assets/js/103.d088091d.js"><link rel="prefetch" href="/assets/js/104.84433564.js"><link rel="prefetch" href="/assets/js/105.3f83d506.js"><link rel="prefetch" href="/assets/js/106.3a28f927.js"><link rel="prefetch" href="/assets/js/107.1ff46145.js"><link rel="prefetch" href="/assets/js/108.884f3482.js"><link rel="prefetch" href="/assets/js/109.d584870e.js"><link rel="prefetch" href="/assets/js/11.a87d6a7c.js"><link rel="prefetch" href="/assets/js/110.ec1e4428.js"><link rel="prefetch" href="/assets/js/111.db024fb8.js"><link rel="prefetch" href="/assets/js/112.1c69b3b7.js"><link rel="prefetch" href="/assets/js/113.775a2bb8.js"><link rel="prefetch" href="/assets/js/114.131b41b0.js"><link rel="prefetch" href="/assets/js/115.efb8e0f2.js"><link rel="prefetch" href="/assets/js/116.baadc61e.js"><link rel="prefetch" href="/assets/js/117.5d19aad3.js"><link rel="prefetch" href="/assets/js/118.e8c4ee34.js"><link rel="prefetch" href="/assets/js/119.032c2543.js"><link rel="prefetch" href="/assets/js/12.dbd893bd.js"><link rel="prefetch" href="/assets/js/120.135db9df.js"><link rel="prefetch" href="/assets/js/121.731fa5d2.js"><link rel="prefetch" href="/assets/js/122.195cb4d8.js"><link rel="prefetch" href="/assets/js/123.17cb5b9f.js"><link rel="prefetch" href="/assets/js/124.82e7c5cd.js"><link rel="prefetch" href="/assets/js/125.ba318516.js"><link rel="prefetch" href="/assets/js/126.3d4464d4.js"><link rel="prefetch" href="/assets/js/127.1593964c.js"><link rel="prefetch" href="/assets/js/128.88bd4f53.js"><link rel="prefetch" href="/assets/js/129.4a9f740e.js"><link rel="prefetch" href="/assets/js/13.3ea75748.js"><link rel="prefetch" href="/assets/js/130.6e38c0f2.js"><link rel="prefetch" href="/assets/js/131.f3d91863.js"><link rel="prefetch" href="/assets/js/132.ef40494c.js"><link rel="prefetch" href="/assets/js/133.d4e86020.js"><link rel="prefetch" href="/assets/js/134.8a760ad1.js"><link rel="prefetch" href="/assets/js/135.809a2abb.js"><link rel="prefetch" href="/assets/js/136.6e7110fb.js"><link rel="prefetch" href="/assets/js/137.0c19aaf4.js"><link rel="prefetch" href="/assets/js/138.3176c5f2.js"><link rel="prefetch" href="/assets/js/139.b4a99568.js"><link rel="prefetch" href="/assets/js/14.8dbb2ccb.js"><link rel="prefetch" href="/assets/js/140.49c3265a.js"><link rel="prefetch" href="/assets/js/141.950622a6.js"><link rel="prefetch" href="/assets/js/142.8ff16601.js"><link rel="prefetch" href="/assets/js/143.bf039239.js"><link rel="prefetch" href="/assets/js/144.1acde388.js"><link rel="prefetch" href="/assets/js/145.39a99056.js"><link rel="prefetch" href="/assets/js/146.9d66fe31.js"><link rel="prefetch" href="/assets/js/147.4f0491e4.js"><link rel="prefetch" href="/assets/js/148.bab68b83.js"><link rel="prefetch" href="/assets/js/15.8105946d.js"><link rel="prefetch" href="/assets/js/150.c7c8beca.js"><link rel="prefetch" href="/assets/js/151.78553d0a.js"><link rel="prefetch" href="/assets/js/152.439d9c6c.js"><link rel="prefetch" href="/assets/js/153.89cabcc3.js"><link rel="prefetch" href="/assets/js/154.07c3e3ac.js"><link rel="prefetch" href="/assets/js/155.ef8c975f.js"><link rel="prefetch" href="/assets/js/156.d72c2f7b.js"><link rel="prefetch" href="/assets/js/157.7c08f160.js"><link rel="prefetch" href="/assets/js/158.cd620f16.js"><link rel="prefetch" href="/assets/js/159.be60d72c.js"><link rel="prefetch" href="/assets/js/16.b9c4c5da.js"><link rel="prefetch" href="/assets/js/160.19c2641c.js"><link rel="prefetch" href="/assets/js/161.42383c22.js"><link rel="prefetch" href="/assets/js/162.cea95cd7.js"><link rel="prefetch" href="/assets/js/163.61cf2de0.js"><link rel="prefetch" href="/assets/js/164.40ecb02d.js"><link rel="prefetch" href="/assets/js/165.a78fdc8c.js"><link rel="prefetch" href="/assets/js/166.8ca1441b.js"><link rel="prefetch" href="/assets/js/167.c1856c83.js"><link rel="prefetch" href="/assets/js/168.b384731c.js"><link rel="prefetch" href="/assets/js/169.5b402ac3.js"><link rel="prefetch" href="/assets/js/17.fd32166f.js"><link rel="prefetch" href="/assets/js/170.cec307a1.js"><link rel="prefetch" href="/assets/js/171.1a82073a.js"><link rel="prefetch" href="/assets/js/172.c9c4ecc0.js"><link rel="prefetch" href="/assets/js/173.c5c9a96c.js"><link rel="prefetch" href="/assets/js/174.fd781876.js"><link rel="prefetch" href="/assets/js/175.dcd56fa3.js"><link rel="prefetch" href="/assets/js/176.88e0ebf6.js"><link rel="prefetch" href="/assets/js/177.70e1f12d.js"><link rel="prefetch" href="/assets/js/178.b857c0b7.js"><link rel="prefetch" href="/assets/js/179.a3556cc4.js"><link rel="prefetch" href="/assets/js/18.d866561c.js"><link rel="prefetch" href="/assets/js/180.b08eece6.js"><link rel="prefetch" href="/assets/js/181.2e10c3d9.js"><link rel="prefetch" href="/assets/js/182.627ec344.js"><link rel="prefetch" href="/assets/js/183.bf3a8f90.js"><link rel="prefetch" href="/assets/js/184.1d730de4.js"><link rel="prefetch" href="/assets/js/185.05719040.js"><link rel="prefetch" href="/assets/js/186.c432acba.js"><link rel="prefetch" href="/assets/js/187.1ef33293.js"><link rel="prefetch" href="/assets/js/188.d81a6541.js"><link rel="prefetch" href="/assets/js/189.481caf9a.js"><link rel="prefetch" href="/assets/js/19.ab11d590.js"><link rel="prefetch" href="/assets/js/190.04cdcfc9.js"><link rel="prefetch" href="/assets/js/191.4f1b2a09.js"><link rel="prefetch" href="/assets/js/192.85731c0e.js"><link rel="prefetch" href="/assets/js/193.9ed53228.js"><link rel="prefetch" href="/assets/js/194.5f918db0.js"><link rel="prefetch" href="/assets/js/195.6f186d54.js"><link rel="prefetch" href="/assets/js/196.8acfa8c8.js"><link rel="prefetch" href="/assets/js/197.47f61a02.js"><link rel="prefetch" href="/assets/js/198.082c0a2a.js"><link rel="prefetch" href="/assets/js/199.ffe925cb.js"><link rel="prefetch" href="/assets/js/20.16309d91.js"><link rel="prefetch" href="/assets/js/200.1056ecd7.js"><link rel="prefetch" href="/assets/js/201.44a08d16.js"><link rel="prefetch" href="/assets/js/202.ac0211eb.js"><link rel="prefetch" href="/assets/js/203.75e3e0e3.js"><link rel="prefetch" href="/assets/js/204.791e6a2d.js"><link rel="prefetch" href="/assets/js/205.0f575e08.js"><link rel="prefetch" href="/assets/js/206.19b2897f.js"><link rel="prefetch" href="/assets/js/207.4185b98c.js"><link rel="prefetch" href="/assets/js/208.d90dd3c7.js"><link rel="prefetch" href="/assets/js/209.9ed9f581.js"><link rel="prefetch" href="/assets/js/21.10ff5880.js"><link rel="prefetch" href="/assets/js/210.ccdb4208.js"><link rel="prefetch" href="/assets/js/211.1dbba26a.js"><link rel="prefetch" href="/assets/js/212.a2314180.js"><link rel="prefetch" href="/assets/js/213.42a97dd6.js"><link rel="prefetch" href="/assets/js/214.e8b86fe5.js"><link rel="prefetch" href="/assets/js/215.82122398.js"><link rel="prefetch" href="/assets/js/216.adfc1a6b.js"><link rel="prefetch" href="/assets/js/217.c06c52c8.js"><link rel="prefetch" href="/assets/js/218.e91c9627.js"><link rel="prefetch" href="/assets/js/219.9d07a542.js"><link rel="prefetch" href="/assets/js/22.2e559a67.js"><link rel="prefetch" href="/assets/js/220.9216e09c.js"><link rel="prefetch" href="/assets/js/221.0776c49f.js"><link rel="prefetch" href="/assets/js/222.7e09d42f.js"><link rel="prefetch" href="/assets/js/223.5c211436.js"><link rel="prefetch" href="/assets/js/224.72e3a928.js"><link rel="prefetch" href="/assets/js/225.584b3edc.js"><link rel="prefetch" href="/assets/js/226.244c295b.js"><link rel="prefetch" href="/assets/js/227.22150789.js"><link rel="prefetch" href="/assets/js/228.9943f3a9.js"><link rel="prefetch" href="/assets/js/229.a3e07ea5.js"><link rel="prefetch" href="/assets/js/23.021d79b1.js"><link rel="prefetch" href="/assets/js/230.43c1bf29.js"><link rel="prefetch" href="/assets/js/231.edebe07d.js"><link rel="prefetch" href="/assets/js/232.c1f37a5c.js"><link rel="prefetch" href="/assets/js/233.8dec1f25.js"><link rel="prefetch" href="/assets/js/234.f6752cfb.js"><link rel="prefetch" href="/assets/js/235.4fc8dae6.js"><link rel="prefetch" href="/assets/js/236.4b099e51.js"><link rel="prefetch" href="/assets/js/237.3aafeb34.js"><link rel="prefetch" href="/assets/js/238.027109de.js"><link rel="prefetch" href="/assets/js/239.b3a3bd51.js"><link rel="prefetch" href="/assets/js/24.cfba775a.js"><link rel="prefetch" href="/assets/js/240.9bf2989f.js"><link rel="prefetch" href="/assets/js/241.f0be206e.js"><link rel="prefetch" href="/assets/js/242.dfd56d96.js"><link rel="prefetch" href="/assets/js/243.b336ad24.js"><link rel="prefetch" href="/assets/js/244.df53a30a.js"><link rel="prefetch" href="/assets/js/245.8198e377.js"><link rel="prefetch" href="/assets/js/246.d45378ad.js"><link rel="prefetch" href="/assets/js/247.d241085a.js"><link rel="prefetch" href="/assets/js/248.fb472105.js"><link rel="prefetch" href="/assets/js/249.78c7b41a.js"><link rel="prefetch" href="/assets/js/25.5a6e2d92.js"><link rel="prefetch" href="/assets/js/250.9780220b.js"><link rel="prefetch" href="/assets/js/251.262bfcd0.js"><link rel="prefetch" href="/assets/js/252.f7491bef.js"><link rel="prefetch" href="/assets/js/253.3eb152fd.js"><link rel="prefetch" href="/assets/js/254.27cbd837.js"><link rel="prefetch" href="/assets/js/255.27b08098.js"><link rel="prefetch" href="/assets/js/256.4d10a55a.js"><link rel="prefetch" href="/assets/js/257.eea341a6.js"><link rel="prefetch" href="/assets/js/26.c5dba1c9.js"><link rel="prefetch" href="/assets/js/27.ae8c09ff.js"><link rel="prefetch" href="/assets/js/28.4a1aaa82.js"><link rel="prefetch" href="/assets/js/29.3b9d72ef.js"><link rel="prefetch" href="/assets/js/3.8a30aff6.js"><link rel="prefetch" href="/assets/js/30.097f525a.js"><link rel="prefetch" href="/assets/js/31.f3d13f1f.js"><link rel="prefetch" href="/assets/js/32.828d2c8e.js"><link rel="prefetch" href="/assets/js/33.c5bf98f7.js"><link rel="prefetch" href="/assets/js/34.b7bf363b.js"><link rel="prefetch" href="/assets/js/35.fa4016d1.js"><link rel="prefetch" href="/assets/js/36.ad21133d.js"><link rel="prefetch" href="/assets/js/37.fce8f265.js"><link rel="prefetch" href="/assets/js/38.36c5b7bc.js"><link rel="prefetch" href="/assets/js/39.391d419e.js"><link rel="prefetch" href="/assets/js/4.47bd1fd8.js"><link rel="prefetch" href="/assets/js/40.c855b68c.js"><link rel="prefetch" href="/assets/js/41.24e6d580.js"><link rel="prefetch" href="/assets/js/42.38a75b22.js"><link rel="prefetch" href="/assets/js/43.d607599a.js"><link rel="prefetch" href="/assets/js/44.6a243358.js"><link rel="prefetch" href="/assets/js/45.d50fa580.js"><link rel="prefetch" href="/assets/js/46.55226aab.js"><link rel="prefetch" href="/assets/js/47.43518cd2.js"><link rel="prefetch" href="/assets/js/48.e917f093.js"><link rel="prefetch" href="/assets/js/49.b0b65e59.js"><link rel="prefetch" href="/assets/js/5.34f64f0a.js"><link rel="prefetch" href="/assets/js/50.7be22d09.js"><link rel="prefetch" href="/assets/js/51.fa5d5b5b.js"><link rel="prefetch" href="/assets/js/52.e3a15294.js"><link rel="prefetch" href="/assets/js/53.368fad62.js"><link rel="prefetch" href="/assets/js/54.d2f568a9.js"><link rel="prefetch" href="/assets/js/55.0905432f.js"><link rel="prefetch" href="/assets/js/56.ef9859b2.js"><link rel="prefetch" href="/assets/js/57.900b34d1.js"><link rel="prefetch" href="/assets/js/58.4d11f4f9.js"><link rel="prefetch" href="/assets/js/59.7d5178dc.js"><link rel="prefetch" href="/assets/js/6.8a1434f6.js"><link rel="prefetch" href="/assets/js/60.429a3219.js"><link rel="prefetch" href="/assets/js/61.b00dce9f.js"><link rel="prefetch" href="/assets/js/62.3ae1da38.js"><link rel="prefetch" href="/assets/js/63.168d8505.js"><link rel="prefetch" href="/assets/js/64.3e379ec5.js"><link rel="prefetch" href="/assets/js/65.e38569ce.js"><link rel="prefetch" href="/assets/js/66.f8682bb7.js"><link rel="prefetch" href="/assets/js/67.1f28867a.js"><link rel="prefetch" href="/assets/js/68.f8d2acf5.js"><link rel="prefetch" href="/assets/js/69.4a82fe7f.js"><link rel="prefetch" href="/assets/js/7.0bfc8698.js"><link rel="prefetch" href="/assets/js/70.414d4d7e.js"><link rel="prefetch" href="/assets/js/71.1a2c8782.js"><link rel="prefetch" href="/assets/js/72.392a2c09.js"><link rel="prefetch" href="/assets/js/73.c5c2acfe.js"><link rel="prefetch" href="/assets/js/74.6a115012.js"><link rel="prefetch" href="/assets/js/75.3e8ba22b.js"><link rel="prefetch" href="/assets/js/76.663925fa.js"><link rel="prefetch" href="/assets/js/77.a7147fb4.js"><link rel="prefetch" href="/assets/js/78.1fda8db0.js"><link rel="prefetch" href="/assets/js/79.91895131.js"><link rel="prefetch" href="/assets/js/8.1d7951b0.js"><link rel="prefetch" href="/assets/js/80.1b83d443.js"><link rel="prefetch" href="/assets/js/81.f5a74850.js"><link rel="prefetch" href="/assets/js/82.c94fe5f7.js"><link rel="prefetch" href="/assets/js/83.8af1e30e.js"><link rel="prefetch" href="/assets/js/84.a65aeb29.js"><link rel="prefetch" href="/assets/js/85.7272b53b.js"><link rel="prefetch" href="/assets/js/86.497f3d06.js"><link rel="prefetch" href="/assets/js/87.9cb14c49.js"><link rel="prefetch" href="/assets/js/88.2a8c899b.js"><link rel="prefetch" href="/assets/js/89.07d5218e.js"><link rel="prefetch" href="/assets/js/9.7e52078a.js"><link rel="prefetch" href="/assets/js/90.95f0030c.js"><link rel="prefetch" href="/assets/js/91.01710300.js"><link rel="prefetch" href="/assets/js/92.8304a034.js"><link rel="prefetch" href="/assets/js/93.6cc65bd2.js"><link rel="prefetch" href="/assets/js/94.e348811c.js"><link rel="prefetch" href="/assets/js/95.b3e48f90.js"><link rel="prefetch" href="/assets/js/96.4593862b.js"><link rel="prefetch" href="/assets/js/97.b9f5209f.js"><link rel="prefetch" href="/assets/js/98.004e088e.js"><link rel="prefetch" href="/assets/js/99.274b6802.js">
    <link rel="stylesheet" href="/assets/css/0.styles.94e8daa7.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/vlogo.png" alt="朽木学社" class="logo"> <span class="site-name can-hide">朽木学社</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠 首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🔥 前端系列教程" class="dropdown-title"><a href="/frontend/" class="link-title">🔥 前端系列教程</a> <span class="title" style="display:none;">🔥 前端系列教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/c8f128/" class="nav-link">📗 《CSS 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">📗 《HTMl 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/0796ba76b4b55368/" class="nav-link">📗 《JavaScript教程》</a></li><li class="dropdown-item"><!----> <a href="/es6/f344d070a1031ef7/" class="nav-link">📗 《ES6 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/e05dce83e5129785/" class="nav-link">📗 《TypeScript 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/5df969/" class="nav-link">📗 《React 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/114158caa9e96df0/" class="nav-link">📗 《Vue 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/e2a169/" class="nav-link">📗 《Webpack 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/15ee91/" class="nav-link">📗 《设计模式 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/ed537f/" class="nav-link">📗 《算法与数据结构 教程》</a></li></ul></div></div><div class="nav-item"><a href="/pages/4a8976/" class="nav-link">📚 前端面试题攻略</a></div><div class="nav-item"><a href="/pages/4b9d5c/" class="nav-link">📖 文章收录</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🔨 实用工具" class="dropdown-title"><!----> <span class="title" style="display:;">🔨 实用工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/pages/8292d8/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/61f2f95fd7da14fd/" class="nav-link">常用软件</a></li><li class="dropdown-item"><!----> <a href="/pages/03e105/" class="nav-link">写文章技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/9ee271/" class="nav-link">Mac使用技巧</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><!----> <span class="title" style="display:;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/1c7cc5/" class="nav-link">实用轮子</a></li><li class="dropdown-item"><!----> <a href="/pages/beb6c0bd8a66cea6/" class="nav-link">实用网站</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">杂货铺</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">👤 关于</a></div> <a href="https://github.com/xiumubai/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/me/weixin.png"> <div class="blogger-info"><h3>Xiumubai</h3> <span>朽木不雕难成才，知耻后勇凌云志</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠 首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🔥 前端系列教程" class="dropdown-title"><a href="/frontend/" class="link-title">🔥 前端系列教程</a> <span class="title" style="display:none;">🔥 前端系列教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/c8f128/" class="nav-link">📗 《CSS 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">📗 《HTMl 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/0796ba76b4b55368/" class="nav-link">📗 《JavaScript教程》</a></li><li class="dropdown-item"><!----> <a href="/es6/f344d070a1031ef7/" class="nav-link">📗 《ES6 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/e05dce83e5129785/" class="nav-link">📗 《TypeScript 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/5df969/" class="nav-link">📗 《React 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/114158caa9e96df0/" class="nav-link">📗 《Vue 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/e2a169/" class="nav-link">📗 《Webpack 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/15ee91/" class="nav-link">📗 《设计模式 教程》</a></li><li class="dropdown-item"><!----> <a href="/pages/ed537f/" class="nav-link">📗 《算法与数据结构 教程》</a></li></ul></div></div><div class="nav-item"><a href="/pages/4a8976/" class="nav-link">📚 前端面试题攻略</a></div><div class="nav-item"><a href="/pages/4b9d5c/" class="nav-link">📖 文章收录</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🔨 实用工具" class="dropdown-title"><!----> <span class="title" style="display:;">🔨 实用工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/pages/8292d8/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/61f2f95fd7da14fd/" class="nav-link">常用软件</a></li><li class="dropdown-item"><!----> <a href="/pages/03e105/" class="nav-link">写文章技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/9ee271/" class="nav-link">Mac使用技巧</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><!----> <span class="title" style="display:;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/1c7cc5/" class="nav-link">实用轮子</a></li><li class="dropdown-item"><!----> <a href="/pages/beb6c0bd8a66cea6/" class="nav-link">实用网站</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">杂货铺</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">👤 关于</a></div> <a href="https://github.com/xiumubai/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/4a8976/" class="sidebar-link">1 前端面试准备</a></li><li><a href="/pages/323c85/" class="sidebar-link">2 程序员面试软技能</a></li><li><a href="/pages/956468/" class="sidebar-link">3 offer收割机之HTML篇</a></li><li><a href="/pages/f5f66f/" class="sidebar-link">4 offer收割机之CSS篇</a></li><li><a href="/pages/739e15/" class="sidebar-link">5 offer收割机之JavaScript篇</a></li><li><a href="/pages/fc9526/" class="sidebar-link">6 offer收割机之性能优化篇</a></li><li><a href="/pages/833648/" class="sidebar-link">7 offer收割机之前端工程化篇</a></li><li><a href="/pages/79089b/" class="sidebar-link">8 offer收割机之计算机网络篇</a></li><li><a href="/pages/7352d9/" class="sidebar-link">9 offer收割机之浏览器原理篇</a></li><li><a href="/pages/b86513/" class="sidebar-link">10 offer收割机之手写代码篇</a></li><li><a href="/pages/797d8b/" class="sidebar-link">11 offer收割机之代码输出篇</a></li><li><a href="/pages/6dc9ec/" class="sidebar-link">12LeetCode面试常考题目</a></li><li><a href="/pages/34cb98/" class="sidebar-link">13 offer收割机之Vue篇</a></li><li><a href="/pages/832bf4/" class="sidebar-link">14 offer收割机之vue项目性能优化</a></li><li><a href="/pages/2b0d4c/" aria-current="page" class="active sidebar-link">15 offer收割机之React篇(上)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/2b0d4c/#一、组件基础" class="sidebar-link">一、组件基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_1-react-事件机制" class="sidebar-link">1. React 事件机制</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_2-react的事件和普通的html事件有什么不同" class="sidebar-link">2. React的事件和普通的HTML事件有什么不同？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_3-react-组件中怎么做事件代理-它的原理是什么" class="sidebar-link">3. React 组件中怎么做事件代理？它的原理是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_4-react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代" class="sidebar-link">4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_5-对react-fiber的理解-它解决了什么问题" class="sidebar-link">5. 对React-Fiber的理解，它解决了什么问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_6-react-component-和-react-purecomponent-的区别" class="sidebar-link">6. React.Component 和 React.PureComponent 的区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_7-component-element-instance-之间有什么区别和联系" class="sidebar-link">7. Component, Element, Instance 之间有什么区别和联系？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_8-react-createclass和extends-component的区别有哪些" class="sidebar-link">8. React.createClass和extends Component的区别有哪些？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_9-react-高阶组件是什么-和普通组件有什么区别-适用什么场景" class="sidebar-link">9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_10-对componentwillreceiveprops-的理解" class="sidebar-link">10. 对componentWillReceiveProps 的理解</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_11-哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么" class="sidebar-link">11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_12-react如何判断什么时候重新渲染组件" class="sidebar-link">12. React如何判断什么时候重新渲染组件？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_13-react声明组件有哪几种方法-有什么不同" class="sidebar-link">13. React声明组件有哪几种方法，有什么不同？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_14-对有状态组件和无状态组件的理解及使用场景" class="sidebar-link">14. 对有状态组件和无状态组件的理解及使用场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_15-对react中fragment的理解-它的使用场景是什么" class="sidebar-link">15. 对React中Fragment的理解，它的使用场景是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_16-react如何获取组件对应的dom元素" class="sidebar-link">16. React如何获取组件对应的DOM元素？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_17-react中可以在render访问refs吗-为什么" class="sidebar-link">17. React中可以在render访问refs吗？为什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_18-对react的插槽-portals-的理解-如何使用-有哪些使用场景" class="sidebar-link">18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_19-在react中如何避免不必要的render" class="sidebar-link">19. 在React中如何避免不必要的render？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_20-对-react-intl-的理解-它的工作原理" class="sidebar-link">20. 对 React-Intl 的理解，它的工作原理？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_21-对-react-context-的理解" class="sidebar-link">21. 对 React context 的理解</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_22-为什么react并不推荐优先考虑使用context" class="sidebar-link">22. 为什么React并不推荐优先考虑使用Context？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_23-react中什么是受控组件和非控组件" class="sidebar-link">23. React中什么是受控组件和非控组件？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_24-react中refs的作用是什么-有哪些应用场景" class="sidebar-link">24. React中refs的作用是什么？有哪些应用场景？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_25-react中除了在构造函数中绑定this-还有别的方式吗" class="sidebar-link">25. React中除了在构造函数中绑定this，还有别的方式吗？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_26-react组件的构造函数有什么作用-它是必须的吗" class="sidebar-link">26. React组件的构造函数有什么作用？它是必须的吗？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_27-react-forwardref是什么-它有什么作用" class="sidebar-link">27. React.forwardRef是什么？它有什么作用？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_28-类组件与函数组件有什么异同" class="sidebar-link">28. 类组件与函数组件有什么异同？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2b0d4c/#二、数据管理" class="sidebar-link">二、数据管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_1-react-setstate-调用的原理" class="sidebar-link">1. React setState 调用的原理</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_2-react-setstate-调用之后发生了什么-是同步还是异步" class="sidebar-link">2. React setState 调用之后发生了什么？是同步还是异步？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_3-react中的setstate批量更新的过程是什么" class="sidebar-link">3. React中的setState批量更新的过程是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_4-react中有使用过getdefaultprops吗-它有什么作用" class="sidebar-link">4.  React中有使用过getDefaultProps吗？它有什么作用？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_5-react中setstate的第二个参数作用是什么" class="sidebar-link">5. React中setState的第二个参数作用是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_6-react中的setstate和replacestate的区别是什么" class="sidebar-link">6. React中的setState和replaceState的区别是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_7-在react中组件的this-state和setstate有什么区别" class="sidebar-link">7. 在React中组件的this.state和setState有什么区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_8-state-是怎么注入到组件的-从-reducer-到组件经历了什么样的过程" class="sidebar-link">8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_9-react组件的state和props有什么区别" class="sidebar-link">9. React组件的state和props有什么区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_10-react中的props为什么是只读的" class="sidebar-link">10. React中的props为什么是只读的？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_11-在react中组件的props改变时更新组件的有哪些方法" class="sidebar-link">11. 在React中组件的props改变时更新组件的有哪些方法？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_12-react中怎么检验props-验证props的目的是什么" class="sidebar-link">12. React中怎么检验props？验证props的目的是什么？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/2b0d4c/#三、生命周期" class="sidebar-link">三、生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_1-react的生命周期有哪些" class="sidebar-link">1. React的生命周期有哪些？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_2-react-废弃了哪些生命周期-为什么" class="sidebar-link">2. React 废弃了哪些生命周期？为什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_3-react-16-x-中-props-改变后在哪个生命周期中处理" class="sidebar-link">3. React 16.X 中 props 改变后在哪个生命周期中处理</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_4-react-性能优化在哪个生命周期-它优化的原理是什么" class="sidebar-link">4. React 性能优化在哪个生命周期？它优化的原理是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_5-state-和-props-触发更新的生命周期分别有什么区别" class="sidebar-link">5. state 和 props 触发更新的生命周期分别有什么区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_6-react中发起网络请求应该在哪个生命周期中进行-为什么" class="sidebar-link">6. React中发起网络请求应该在哪个生命周期中进行？为什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_7-react-16中新生命周期有哪些" class="sidebar-link">7. React 16中新生命周期有哪些</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_1-react组件命名推荐的方式是哪个" class="sidebar-link">1. React组件命名推荐的方式是哪个？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_2-react-最新版本解决了什么问题-增加了哪些东西" class="sidebar-link">2. react 最新版本解决了什么问题，增加了哪些东西</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_3-react-实现一个全局的-dialog" class="sidebar-link">3. react 实现一个全局的 dialog</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_4-react-数据持久化有什么实践吗" class="sidebar-link">4. React 数据持久化有什么实践吗？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_5-对-react-和-vue-的理解-它们的异同" class="sidebar-link">5. 对 React 和 Vue 的理解，它们的异同</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_6-可以使用typescript写react应用吗-怎么操作" class="sidebar-link">6. 可以使用TypeScript写React应用吗？怎么操作？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_7-react-设计思路-它的理念是什么" class="sidebar-link">7. React 设计思路，它的理念是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_8-react中props-children和react-children的区别" class="sidebar-link">8. React中props.children和React.Children的区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_9-react的状态提升是什么-使用场景有哪些" class="sidebar-link">9. React的状态提升是什么？使用场景有哪些？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_10-react中constructor和getinitialstate的区别" class="sidebar-link">10. React中constructor和getInitialState的区别?</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_11-react的严格模式如何使用-有什么用处" class="sidebar-link">11. React的严格模式如何使用，有什么用处？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_12-在react中遍历的方法有哪些" class="sidebar-link">12. 在React中遍历的方法有哪些？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_13-在react中页面重新加载时怎样保留数据" class="sidebar-link">13. 在React中页面重新加载时怎样保留数据？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_14-同时引用这三个库react-js、react-dom-js和babel-js它们都有什么作用" class="sidebar-link">14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_15-react必须使用jsx吗" class="sidebar-link">15. React必须使用JSX吗？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_16-为什么使用jsx的组件中没有看到使用react却需要引入react" class="sidebar-link">16. 为什么使用jsx的组件中没有看到使用react却需要引入react？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_17-在react中怎么使用async-await" class="sidebar-link">17. 在React中怎么使用async/await？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_18-react-children-map和js的map有什么区别" class="sidebar-link">18. React.Children.map和js的map有什么区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_19-对react-ssr的理解" class="sidebar-link">19. 对React SSR的理解</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_20-为什么-react-要用-jsx" class="sidebar-link">20. 为什么 React 要用 JSX？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_21-hoc相比-mixins-有什么优点" class="sidebar-link">21. HOC相比 mixins 有什么优点？</a></li><li class="sidebar-sub-header level3"><a href="/pages/2b0d4c/#_22-react-中的高阶组件运用了什么设计模式" class="sidebar-link">22. React 中的高阶组件运用了什么设计模式？</a></li></ul></li></ul></li><li><a href="/pages/cb0032/" class="sidebar-link">16 offer收割机之React篇(中)</a></li><li><a href="/pages/2ecbb3/" class="sidebar-link">17 offer收割机之React篇(下)</a></li><li><a href="/pages/c5cd3d/" class="sidebar-link">简历模板</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%94%BB%E7%95%A5" title="分类" data-v-06225672>前端面试攻略</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/xiumubai" target="_blank" title="作者" class="beLink" data-v-06225672>xiumubai</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-03-13</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">15 offer收割机之React篇(上)<!----></h1>  <div class="theme-vdoing-content content__default"><p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1618317949340-04bf1cbc-f74c-4f76-8dbf-fe7de4714d30-20220328163458377.png" alt="React面试题.png"></p> <h2 id="一、组件基础"><a href="#一、组件基础" class="header-anchor">#</a> 一、组件基础</h2> <h3 id="_1-react-事件机制"><a href="#_1-react-事件机制" class="header-anchor">#</a> 1. React 事件机制</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;div onClick={this.handleClick.bind(this)}&gt;点我&lt;/div&gt;
</code></pre></div><p>React并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。</p> <p>除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。</p> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1611890469312-7504e85d-c6db-481e-b9d3-5307a3de708c.png" alt="77fa6b2a59c92e160bc171f9c80783e7.jpg"></p> <p>JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 <code>document</code> 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p> <p>另外冒泡到 <code>document</code> 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 <code>event.stopPropagation</code> 是无效的，而应该调用 <code>event.preventDefault</code>。</p> <p>实现合成事件的目的如下：</p> <ul><li>合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；</li> <li>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li></ul> <h3 id="_2-react的事件和普通的html事件有什么不同"><a href="#_2-react的事件和普通的html事件有什么不同" class="header-anchor">#</a> 2. React的事件和普通的HTML事件有什么不同？</h3> <p>区别：</p> <ul><li>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</li> <li>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</li> <li>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用<code>preventDefault()</code>来阻止默认行为。</li></ul> <p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p> <ul><li>兼容所有浏览器，更好的跨平台；</li> <li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li> <li>方便 react 统一管理和事务机制。</li></ul> <p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p> <h3 id="_3-react-组件中怎么做事件代理-它的原理是什么"><a href="#_3-react-组件中怎么做事件代理-它的原理是什么" class="header-anchor">#</a> 3. React 组件中怎么做事件代理？它的原理是什么？</h3> <p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。</p> <p>在React底层，主要对合成事件做了两件事：</p> <ul><li>**事件委派：**React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</li> <li>**自动绑定：**React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</li></ul> <h3 id="_4-react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代"><a href="#_4-react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代" class="header-anchor">#</a> 4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h3> <p>这三者是目前react解决代码复用的主要方式：</p> <ul><li>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</li> <li>render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</li> <li>通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。</li></ul> <p><strong>（1）HOC</strong></p> <p>官方解释∶</p> <blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p></blockquote> <p>简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// hoc的定义</span>
<span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent<span class="token punctuation">,</span> selectData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span>DataSource<span class="token punctuation">,</span> props<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 一些通用的逻辑处理</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... 并使用新数据渲染被包装的组件!</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>data<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">const</span> BlogPostWithSubscription <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>BlogPost<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">DataSource<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> DataSource<span class="token punctuation">.</span><span class="token function">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>HOC的优缺点∶</p> <ul><li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。</li> <li>缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li></ul> <p><strong>（2）Render props</strong></p> <p>官方解释∶</p> <blockquote><p>&quot;render prop&quot;是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p></blockquote> <p>具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，&quot;render&quot;的命名可以是任何其他有效的标识符。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// DataProvider组件内部的渲染逻辑如下</span>
<span class="token keyword">class</span> <span class="token class-name">DataProvider</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Components</span> <span class="token punctuation">{</span>
     state <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Tom'</span>
  <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>共享数据组件自己内部的渲染逻辑<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
          <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用方式</span>
<span class="token operator">&lt;</span>DataProvider render<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello <span class="token punctuation">{</span>data<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>由此可以看到，render props的优缺点也很明显∶</p> <ul><li>优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。</li> <li>缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</li></ul> <p><strong>（3）Hooks</strong></p> <p>官方解释∶</p> <blockquote><p>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 自定义一个获取订阅数据的hook</span>
<span class="token keyword">function</span> <span class="token function">useSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> DataSource<span class="token punctuation">.</span><span class="token function">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// </span>
<span class="token keyword">function</span> <span class="token function">CommentList</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>data<span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>subData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
<span class="token operator">&lt;</span>CommentList data<span class="token operator">=</span><span class="token string">'hello'</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶</p> <ul><li>使用直观；</li> <li>解决hoc的prop 重名问题；</li> <li>解决render props 因共享数据 而出现嵌套地狱的问题；</li> <li>能在return之外使用数据的问题。</li></ul> <p>需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。</p> <p><strong>总结∶</strong></p> <p>Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</p> <h3 id="_5-对react-fiber的理解-它解决了什么问题"><a href="#_5-对react-fiber的理解-它解决了什么问题" class="header-anchor">#</a> 5. 对React-Fiber的理解，它解决了什么问题？</h3> <p>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，<strong>导致用户感觉到卡顿</strong>。</p> <p>为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。</p> <p>所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:</p> <ul><li>分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；</li> <li>给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。</li></ul> <h4 id=""><a href="#" class="header-anchor">#</a></h4> <p>**核心思想：**Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p> <h3 id="_6-react-component-和-react-purecomponent-的区别"><a href="#_6-react-component-和-react-purecomponent-的区别" class="header-anchor">#</a> 6. React.Component 和 React.PureComponent 的区别</h3> <p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。</p> <p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p> <p>不过，pureComponent中的 shouldComponentUpdate() 进行的是<strong>浅比较</strong>，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p> <p>使用pureComponent的<strong>好处</strong>：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p> <h3 id="_7-component-element-instance-之间有什么区别和联系"><a href="#_7-component-element-instance-之间有什么区别和联系" class="header-anchor">#</a> 7. Component, Element, Instance 之间有什么区别和联系？</h3> <ul><li>**元素：**一个元素<code>element</code>是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件<code>component</code>，你想让它在屏幕上呈现成什么样子。元素<code>element</code>可以在它的属性<code>props</code>中包含其他元素(译注:用于形成元素树)。创建一个React元素<code>element</code>成本很低。元素<code>element</code>创建之后是不可变的。</li> <li>**组件：**一个组件<code>component</code>可以通过多种方式声明。可以是带有一个<code>render()</code>方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性<code>props</code>作为输入，把返回的一棵元素树作为输出。</li> <li>**实例：**一个实例<code>instance</code>是你在所写的组件类<code>component class</code>中使用关键字<code>this</code>所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</li></ul> <p>函数式组件(<code>Functional component</code>)根本没有实例<code>instance</code>。类组件(<code>Class component</code>)有实例<code>instance</code>，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p> <h3 id="_8-react-createclass和extends-component的区别有哪些"><a href="#_8-react-createclass和extends-component的区别有哪些" class="header-anchor">#</a> 8. React.createClass和extends Component的区别有哪些？</h3> <p>React.createClass和extends Component的bai区别主要在于：</p> <p><strong>（1）语法区别</strong></p> <ul><li>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</li> <li>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</li></ul> <p><strong>（2）propType 和 getDefaultProps</strong></p> <ul><li>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</li> <li>React.Component：通过设置两个属性propTypes和defaultProps</li></ul> <p><strong>（3）状态的区别</strong></p> <ul><li>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</li> <li>React.Component：通过constructor设置初始状态</li></ul> <p><strong>（4）this区别</strong></p> <ul><li>React.createClass：会正确绑定this</li> <li>React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。</li></ul> <p><strong>（5）Mixins</strong></p> <ul><li>React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。</li> <li>如果使用 ES6 的方式来创建组件，那么 <code>React mixins</code> 的特性将不能被使用了。</li></ul> <h3 id="_9-react-高阶组件是什么-和普通组件有什么区别-适用什么场景"><a href="#_9-react-高阶组件是什么-和普通组件有什么区别-适用什么场景" class="header-anchor">#</a> 9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景</h3> <p>官方解释∶</p> <blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p></blockquote> <p>高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// hoc的定义</span>
<span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent<span class="token punctuation">,</span> selectData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span>DataSource<span class="token punctuation">,</span> props<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 一些通用的逻辑处理</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... 并使用新数据渲染被包装的组件!</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>data<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">const</span> BlogPostWithSubscription <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>BlogPost<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">DataSource<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> DataSource<span class="token punctuation">.</span><span class="token function">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>1）HOC的优缺点</strong></p> <ul><li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。</li> <li>缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li></ul> <p><strong>2）适用场景</strong></p> <ul><li>代码复用，逻辑抽象</li> <li>渲染劫持</li> <li>State 抽象和更改</li> <li>Props 更改</li></ul> <p><strong>3）具体应用例子</strong></p> <ul><li>**权限控制：**利用高阶组件的 <strong>条件渲染</strong> 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// HOC.js</span>
<span class="token keyword">function</span> <span class="token function">withAdminAuth</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
        state <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">isAdmin</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">async</span> <span class="token function">UNSAFE_componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> currentRole <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getCurrentUserRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                <span class="token literal-property property">isAdmin</span><span class="token operator">:</span> currentRole <span class="token operator">===</span> <span class="token string">'Admin'</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>isAdmin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>您没有权限查看该页面，请联系管理员！<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// pages/page-a.js</span>
<span class="token keyword">class</span> <span class="token class-name">PageA</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// something here...</span>
    <span class="token punctuation">}</span>
    <span class="token function">UNSAFE_componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// fetching data</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// render page with data</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withAdminAuth</span><span class="token punctuation">(</span>PageA<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// pages/page-b.js</span>
<span class="token keyword">class</span> <span class="token class-name">PageB</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// something here...</span>
        <span class="token punctuation">}</span>
    <span class="token function">UNSAFE_componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// fetching data</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// render page with data</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withAdminAuth</span><span class="token punctuation">(</span>PageB<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>**组件渲染性能追踪：**借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录∶</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Home</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello World<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">withTiming</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> WrappedComponent <span class="token punctuation">{</span>
            <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">UNSAFE_componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">.</span>componentWillMount <span class="token operator">&amp;&amp;</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">.</span>componentDidMount <span class="token operator">&amp;&amp;</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>WrappedComponent<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 组件渲染时间为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>start<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withTiming</span><span class="token punctuation">(</span>Home<span class="token punctuation">)</span><span class="token punctuation">;</span>   
</code></pre></div><p>注意：withTiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间。</p> <ul><li><strong>页面复用</strong></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">withFetching</span> <span class="token operator">=</span> <span class="token parameter">fetching</span> <span class="token operator">=&gt;</span> <span class="token parameter">WrappedComponent</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
        state <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">async</span> <span class="token function">UNSAFE_componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetching</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                data<span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>data<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// pages/page-a.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withFetching</span><span class="token punctuation">(</span><span class="token function">fetching</span><span class="token punctuation">(</span><span class="token string">'science-fiction'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>MovieList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// pages/page-b.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withFetching</span><span class="token punctuation">(</span><span class="token function">fetching</span><span class="token punctuation">(</span><span class="token string">'action'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>MovieList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// pages/page-other.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withFetching</span><span class="token punctuation">(</span><span class="token function">fetching</span><span class="token punctuation">(</span><span class="token string">'some-other-type'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>MovieList<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_10-对componentwillreceiveprops-的理解"><a href="#_10-对componentwillreceiveprops-的理解" class="header-anchor">#</a> 10. 对componentWillReceiveProps 的理解</h3> <p>该方法当<code>props</code>发生变化时执行，初始化<code>render</code>时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用<code>this.setState()</code>来更新你的组件状态，旧的属性还是可以通过<code>this.props</code>来获取,这里调用更新状态是安全的，并不会触发额外的<code>render</code>调用。</p> <p>**使用好处：**在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</p> <h3 id="_11-哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么"><a href="#_11-哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么" class="header-anchor">#</a> 11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h3> <p><strong>（1）哪些方法会触发 react 重新渲染?</strong></p> <ul><li><strong>setState（）方法被调用</strong></li></ul> <p>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;render&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragement<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button
          onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里并没有改变 a 的值</span>
          <span class="token punctuation">}</span><span class="token punctuation">}</span>
        <span class="token operator">&gt;</span>
          Click me
        <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>setState <span class="token keyword">null</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Child <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragement<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>父组件重新渲染</strong></li></ul> <p>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render</p> <p><strong>（2）重新渲染 render 会做些什么?</strong></p> <ul><li>会对新旧 VNode 进行对比，也就是我们所说的Diff算法。</li> <li>对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</li> <li>遍历差异对象，根据差异的类型，根据对应对规则更新VNode</li></ul> <p>React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.</p> <h3 id="_12-react如何判断什么时候重新渲染组件"><a href="#_12-react如何判断什么时候重新渲染组件" class="header-anchor">#</a> 12. React如何判断什么时候重新渲染组件？</h3> <p>组件状态的改变可以因为<code>props</code>的改变，或者直接通过<code>setState</code>方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的<code>shouldComponentUpdate</code>方法默认返回<code>true</code>，这就是导致每次更新都重新渲染的原因。</p> <p>当React将要渲染组件时会执行<code>shouldComponentUpdate</code>方法来看它是否返回<code>true</code>（组件应该更新，也就是重新渲染）。所以需要重写<code>shouldComponentUpdate</code>方法让它根据情况返回<code>true</code>或者<code>false</code>来告诉React什么时候重新渲染什么时候跳过重新渲染。</p> <h3 id="_13-react声明组件有哪几种方法-有什么不同"><a href="#_13-react声明组件有哪几种方法-有什么不同" class="header-anchor">#</a> 13. React声明组件有哪几种方法，有什么不同？</h3> <p>React 声明组件的三种方式：</p> <ul><li>函数式定义的<code>无状态组件</code></li> <li>ES5原生方式<code>React.createClass</code>定义的组件</li> <li>ES6形式的<code>extends React.Component</code>定义的组件</li></ul> <p><strong>（1）无状态函数式组件</strong></p> <p>它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作</p> <p>组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法</p> <p><strong>（2）ES5 原生方式 React.createClass // RFC</strong></p> <p>React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。</p> <p><strong>（3）E6继承形式 React.Component // RCC</strong></p> <p>目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。</p> <p><strong>无状态组件相对于于后者的区别：</strong></p> <p>与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。</p> <p><strong>React.createClass与React.Component区别：</strong></p> <p><strong>① 函数this自绑定</strong></p> <ul><li>React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。</li> <li>React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。</li></ul> <p><strong>② 组件属性类型propTypes及其默认props属性defaultProps配置不同</strong></p> <ul><li>React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的</li> <li>React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。</li></ul> <p><strong>③ 组件初始状态state的配置不同</strong></p> <ul><li>React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；</li> <li>React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。</li></ul> <h3 id="_14-对有状态组件和无状态组件的理解及使用场景"><a href="#_14-对有状态组件和无状态组件的理解及使用场景" class="header-anchor">#</a> 14. 对有状态组件和无状态组件的理解及使用场景</h3> <p><strong>（1）有状态组件</strong></p> <p><strong>特点：</strong></p> <ul><li>是类组件</li> <li>有继承</li> <li>可以使用this</li> <li>可以使用react的生命周期</li> <li>使用较多，容易频繁触发生命周期钩子函数，影响性能</li> <li>内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。</li></ul> <p><strong>使用场景：</strong></p> <ul><li>需要使用到状态的。</li> <li>需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）</li></ul> <p><strong>总结：</strong></p> <p>类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。</p> <p><strong>（2）无状态组件</strong></p> <p><strong>特点：</strong></p> <ul><li>不依赖自身的状态state</li> <li>可以是类组件或者函数组件。</li> <li>可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）</li> <li>有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件</li> <li>组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。</li></ul> <p><strong>使用场景：</strong></p> <ul><li>组件不需要管理 state，纯展示</li></ul> <p><strong>优点：</strong></p> <ul><li>简化代码、专注于 render</li> <li>组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用</li> <li>视图和数据的解耦分离</li></ul> <p><strong>缺点：</strong></p> <ul><li>无法使用 ref</li> <li>无生命周期方法</li> <li>无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染</li></ul> <p><strong>总结：</strong></p> <p>组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 <code>&lt;Button/&gt;</code>、 <code>&lt;Input /&gt;</code> 等组件。</p> <h3 id="_15-对react中fragment的理解-它的使用场景是什么"><a href="#_15-对react中fragment的理解-它的使用场景是什么" class="header-anchor">#</a> 15. 对React中Fragment的理解，它的使用场景是什么？</h3> <p>在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：</p> <blockquote><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Fragment <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token comment">// 一般形式</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildA <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildB <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildC <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 也可以写成以下形式</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildA <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildB <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ChildC <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_16-react如何获取组件对应的dom元素"><a href="#_16-react如何获取组件对应的dom元素" class="header-anchor">#</a> 16. React如何获取组件对应的DOM元素？</h3> <p>可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:</p> <ul><li><strong>字符串格式</strong>：字符串格式，这是React16版本之前用得最多的，例如：<code>&lt;p ref=&quot;info&quot;&gt;span&lt;/p&gt;</code></li> <li><strong>函数格式</strong>：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：<code>&lt;p ref={ele =&gt; this.info = ele}&gt;&lt;/p&gt;</code></li> <li><strong>createRef方法</strong>：React 16提供的一个API，使用React.createRef()来实现</li></ul> <h3 id="_17-react中可以在render访问refs吗-为什么"><a href="#_17-react中可以在render访问refs吗-为什么" class="header-anchor">#</a> 17. React中可以在render访问refs吗？为什么？</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">&quot;name&quot;</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>spanRef<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span><span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>spanRef<span class="token punctuation">.</span>current <span class="token operator">?</span> <span class="token string">'有值'</span> <span class="token operator">:</span> <span class="token string">'无值'</span>
  <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：</p> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1611822510207-8101671e-8b5a-4968-88b1-85d44e078b0b.png" alt="image.png"></p> <h3 id="_18-对react的插槽-portals-的理解-如何使用-有哪些使用场景"><a href="#_18-对react的插槽-portals-的理解-如何使用-有哪些使用场景" class="header-anchor">#</a> 18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景</h3> <p>React 官方对 Portals 的定义：</p> <blockquote><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案</p></blockquote> <p>Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。</p> <p>Portals语法如下：</p> <div class="language- extra-class"><pre class="language-text"><code>ReactDOM.createPortal(child, container);
</code></pre></div><ul><li>第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;</li> <li>第二个参数 container 是一个 DOM 元素。</li></ul> <p>一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> DemoComponent <span class="token keyword">from</span> <span class="token string">'./DemoComponent'</span><span class="token punctuation">;</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DemoComponent元素会被挂载在id为parent的div的元素上</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;parent&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>DemoComponent <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有<code>overflow: hidden</code>或者<code>z-index</code>的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> DemoComponent <span class="token keyword">from</span> <span class="token string">'./DemoComponent'</span><span class="token punctuation">;</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// react会将DemoComponent组件直接挂载在真实的 dom 节点 domNode 上，生命周期还和16版本之前相同。</span>
  <span class="token keyword">return</span> ReactDOM<span class="token punctuation">.</span><span class="token function">createPortal</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>DemoComponent <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    domNode<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_19-在react中如何避免不必要的render"><a href="#_19-在react中如何避免不必要的render" class="header-anchor">#</a> 19. 在React中如何避免不必要的render？</h3> <p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：</p> <ul><li><strong>shouldComponentUpdate 和 PureComponent</strong></li></ul> <p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p> <ul><li><strong>利用高阶组件</strong></li></ul> <p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p> <ul><li><strong>使用 React.memo</strong></li></ul> <p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p> <h3 id="_20-对-react-intl-的理解-它的工作原理"><a href="#_20-对-react-intl-的理解-它的工作原理" class="header-anchor">#</a> 20. 对 React-Intl 的理解，它的工作原理？</h3> <p>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</p> <p>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</p> <p>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</p> <h3 id="_21-对-react-context-的理解"><a href="#_21-对-react-context-的理解" class="header-anchor">#</a> 21. 对 React context 的理解</h3> <p>在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。</p> <p>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p> <p>可以把context当做是特定一个组件树内共享的store，用来做数据传递。<strong>简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</strong></p> <p>JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。</p> <p>假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。</p> <h3 id="_22-为什么react并不推荐优先考虑使用context"><a href="#_22-为什么react并不推荐优先考虑使用context" class="header-anchor">#</a> 22. 为什么React并不推荐优先考虑使用Context？</h3> <ul><li>Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。</li> <li>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context</li> <li>对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。</li> <li>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</li></ul> <h3 id="_23-react中什么是受控组件和非控组件"><a href="#_23-react中什么是受控组件和非控组件" class="header-anchor">#</a> 23. React中什么是受控组件和非控组件？</h3> <p><strong>（1）受控组件</strong></p> <p>在使用表单来收集用户输入时，例如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为<strong>受控组件</strong>，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</p> <p>受控组件更新state的流程：</p> <ul><li>可以通过初始state中设置表单的默认值</li> <li>每当表单的值发生变化时，调用onChange事件处理器</li> <li>事件处理器通过事件对象e拿到改变后的状态，并更新组件的state</li> <li>一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</li></ul> <p><strong>受控组件缺陷：</strong></p> <p>表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</p> <p><strong>（2）非受控组件</strong></p> <p>如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</p> <p>React官方的解释：</p> <blockquote><p>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。</p> <p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p></blockquote> <p>例如，下面的代码在非受控组件中接收单个属性：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">NameForm</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleSubmit</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">handleSubmit</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'A name was submitted: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>input<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>label<span class="token operator">&gt;</span>
          <span class="token literal-property property">Name</span><span class="token operator">:</span>
          <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>input <span class="token operator">=</span> input<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;Submit&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>**总结：**页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</p> <h3 id="_24-react中refs的作用是什么-有哪些应用场景"><a href="#_24-react中refs的作用是什么-有哪些应用场景" class="header-anchor">#</a> 24. React中refs的作用是什么？有哪些应用场景？</h3> <p>Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：</p> <ul><li>处理焦点、文本选择或者媒体的控制</li> <li>触发必要的动画</li> <li>集成第三方 DOM 库</li></ul> <p>Refs 是使用 <code>React.createRef()</code> 方法创建的，他通过 <code>ref</code> 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 <code>ref</code> 在构造函数中分配给其实例属性：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>myRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>myRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于函数组件没有实例，因此不能在函数组件上直接使用 <code>ref</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">MyFunctionalComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>textInput <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这将不会工作！</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>MyFunctionalComponent ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但可以通过闭合的帮助在函数组件内部进行使用 Refs：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">CustomTextInput</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里必须声明 textInput，这样 ref 回调才可以引用它</span>
  <span class="token keyword">let</span> textInput <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    textInput<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input
        type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span>
        ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> textInput <span class="token operator">=</span> input<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input
        type<span class="token operator">=</span><span class="token string">&quot;button&quot;</span>
        value<span class="token operator">=</span><span class="token string">&quot;Focus the text input&quot;</span>
        onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span>
      <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意：</strong></p> <ul><li><p>不应该过度的使用 Refs</p></li> <li><p><code>ref</code> 的返回值取决于节点的类型：</p></li> <li><ul><li>当 <code>ref</code> 属性被用于一个普通的 HTML 元素时，<code>React.createRef()</code> 将接收底层 DOM 元素作为他的 <code>current</code> 属性以创建 <code>ref</code>。</li> <li>当 <code>ref</code> 属性被用于一个自定义的类组件时，<code>ref</code> 对象将接收该组件已挂载的实例作为他的 <code>current</code>。</li></ul></li> <li><p>当在父组件中需要访问子组件中的 <code>ref</code> 时可使用传递 Refs 或回调 Refs。</p></li></ul> <h3 id="_25-react中除了在构造函数中绑定this-还有别的方式吗"><a href="#_25-react中除了在构造函数中绑定this-还有别的方式吗" class="header-anchor">#</a> 25. React中除了在构造函数中绑定this，还有别的方式吗？</h3> <ul><li>在构造函数中绑定this</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> 
       <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token punctuation">{</span>
           <span class="token literal-property property">msg</span><span class="token operator">:</span><span class="token string">'hello world'</span><span class="token punctuation">,</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>getMsg <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMsg</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
</code></pre></div><ul><li>函数定义的时候使用箭头函数</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token punctuation">{</span>
           <span class="token literal-property property">msg</span><span class="token operator">:</span><span class="token string">'hello world'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token operator">&lt;</span>button onClcik<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>点我<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>函数调用是使用bind绑定this</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMsg</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>点我<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
</code></pre></div><h3 id="_26-react组件的构造函数有什么作用-它是必须的吗"><a href="#_26-react组件的构造函数有什么作用-它是必须的吗" class="header-anchor">#</a> 26. React组件的构造函数有什么作用？它是必须的吗？</h3> <p>构造函数主要用于两个目的：</p> <ul><li>通过将对象分配给this.state来初始化本地状态</li> <li>将事件处理程序方法绑定到实例上</li></ul> <p>所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">LikeButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">liked</span><span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">liked</span><span class="token operator">:</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>liked<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>liked <span class="token operator">?</span> <span class="token string">'liked'</span> <span class="token operator">:</span> <span class="token string">'haven\'t liked'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        You <span class="token punctuation">{</span>text<span class="token punctuation">}</span> <span class="token keyword">this</span><span class="token punctuation">.</span> Click to toggle<span class="token punctuation">.</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>LikeButton <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。</p> <p><strong>注意：</strong></p> <ul><li>constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用</li> <li>JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件</li></ul> <h3 id="_27-react-forwardref是什么-它有什么作用"><a href="#_27-react-forwardref是什么-它有什么作用" class="header-anchor">#</a> 27. React.forwardRef是什么？它有什么作用？</h3> <p>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：</p> <ul><li>转发 refs 到 DOM 组件</li> <li>在高阶组件中转发 refs</li></ul> <h3 id="_28-类组件与函数组件有什么异同"><a href="#_28-类组件与函数组件有什么异同" class="header-anchor">#</a> 28. 类组件与函数组件有什么异同？</h3> <p><strong>相同点：</strong></p> <p>组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。</p> <p>我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。</p> <p><strong>不同点：</strong></p> <ul><li>它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。</li> <li>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。</li> <li>性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。</li> <li>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</li> <li>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</li></ul> <h2 id="二、数据管理"><a href="#二、数据管理" class="header-anchor">#</a> 二、数据管理</h2> <h3 id="_1-react-setstate-调用的原理"><a href="#_1-react-setstate-调用的原理" class="header-anchor">#</a> 1. React setState 调用的原理</h3> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1611908814278-be06f25f-ee6f-44d5-93f1-c0a24eecd456.png" alt="image.png"></p> <p>具体的执行过程如下（源码级解析）：</p> <ul><li>首先调用了<code>setState</code> 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">ReactComponent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">partialState<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">'setState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>enqueueSetState</code> 方法将新的 <code>state</code> 放进组件的状态队列里，并调用 <code>enqueueUpdate</code> 来处理将要更新的实例对象；</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function-variable function">enqueueSetState</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> partialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 this 拿到对应的组件实例</span>
  <span class="token keyword">var</span> internalInstance <span class="token operator">=</span> <span class="token function">getInternalInstanceReadyForUpdate</span><span class="token punctuation">(</span>publicInstance<span class="token punctuation">,</span> <span class="token string">'setState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 这个 queue 对应的就是一个组件实例的 state 数组</span>
  <span class="token keyword">var</span> queue <span class="token operator">=</span> internalInstance<span class="token punctuation">.</span>_pendingStateQueue <span class="token operator">||</span> <span class="token punctuation">(</span>internalInstance<span class="token punctuation">.</span>_pendingStateQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>partialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//  enqueueUpdate 用来处理当前的组件实例</span>
  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>internalInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>在 <code>enqueueUpdate</code> 方法中引出了一个关键的对象——<code>batchingStrategy</code>，该对象所具备的<code>isBatchingUpdates</code> 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 <code>batchedUpdates</code> 方法来直接发起更新流程。由此可以推测，<code>batchingStrategy</code> 或许正是 React 内部专门用于管控批量更新的对象。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token parameter">component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ensureInjected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>batchingStrategy<span class="token punctuation">.</span>isBatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span>
    batchingStrategy<span class="token punctuation">.</span><span class="token function">batchedUpdates</span><span class="token punctuation">(</span>enqueueUpdate<span class="token punctuation">,</span> component<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span>
  dirtyComponents<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>component<span class="token punctuation">.</span>_updateBatchNumber <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    component<span class="token punctuation">.</span>_updateBatchNumber <span class="token operator">=</span> updateBatchNumber <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意：</strong><code>batchingStrategy</code> 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 <code>isBatchingUpdates</code> 变量，<code>isBatchingUpdates</code> 的初始值是 <code>false</code>，意味着“当前并未进行任何批量更新操作”。每当 React 调用 <code>batchedUpdate</code> 去执行更新动作时，会先把这个锁给“锁上”（置为 <code>true</code>），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 <code>dirtyComponents</code> 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</p> <h3 id="_2-react-setstate-调用之后发生了什么-是同步还是异步"><a href="#_2-react-setstate-调用之后发生了什么-是同步还是异步" class="header-anchor">#</a> 2. React setState 调用之后发生了什么？是同步还是异步？</h3> <p><strong>（1）React中setState后发生了什么</strong></p> <p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。</p> <p>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p> <p>如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。</p> <p><strong>（2）setState 是同步还是异步的</strong></p> <p>假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。</p> <p>setState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</p> <ul><li>**异步：**在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</li> <li>**同步：**在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</li></ul> <p>一般认为，做异步设计是为了性能优化、减少渲染次数：</p> <ul><li><code>setState</code>设计为异步，可以显著的提升性能。如果每次调用 <code>setState</code>都进行一次更新，那么意味着<code>render</code>函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新；</li> <li>如果同步更新了<code>state</code>，但是还没有执行<code>render</code>函数，那么<code>state</code>和<code>props</code>不能保持同步。<code>state</code>和<code>props</code>不能保持一致性，会在开发中产生很多的问题；</li></ul> <h3 id="_3-react中的setstate批量更新的过程是什么"><a href="#_3-react中的setstate批量更新的过程是什么" class="header-anchor">#</a> 3. React中的setState批量更新的过程是什么？</h3> <p>调用 <code>setState</code> 时，组件的 <code>state</code> 并不会立即改变， <code>setState</code> 只是把要修改的 <code>state</code> 放入一个队列， <code>React</code> 会优化真正的执行时机，并出于性能原因，会将 <code>React</code> 事件处理程序中的多次<code>React</code> 事件处理程序中的多次 <code>setState</code> 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>    <span class="token operator">===</span><span class="token operator">&gt;</span>    入队，<span class="token punctuation">[</span>count<span class="token operator">+</span><span class="token number">1</span>的任务<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>    <span class="token operator">===</span><span class="token operator">&gt;</span>    入队，<span class="token punctuation">[</span>count<span class="token operator">+</span><span class="token number">1</span>的任务，count<span class="token operator">+</span><span class="token number">1</span>的任务<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                          ↓
                                         合并 state，<span class="token punctuation">[</span>count<span class="token operator">+</span><span class="token number">1</span>的任务<span class="token punctuation">]</span>
                                          ↓
                                         执行 count<span class="token operator">+</span><span class="token number">1</span>的任务
</code></pre></div><p>需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</p> <h3 id="_4-react中有使用过getdefaultprops吗-它有什么作用"><a href="#_4-react中有使用过getdefaultprops吗-它有什么作用" class="header-anchor">#</a> 4.  React中有使用过getDefaultProps吗？它有什么作用？</h3> <p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> ShowTitle <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">getDefaultProps</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
      <span class="token literal-property property">title</span> <span class="token operator">:</span> <span class="token string">&quot;React&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_5-react中setstate的第二个参数作用是什么"><a href="#_5-react中setstate的第二个参数作用是什么" class="header-anchor">#</a> 5. React中setState的第二个参数作用是什么？</h3> <p><code>setState</code> 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 <code>componentDidUpdate</code> 生命周期内执行。通常建议使用 <code>componentDidUpdate</code> 来代替此方式。在这个回调函数中你可以拿到更新后 <code>state</code> 的值：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">key1</span><span class="token operator">:</span> newState1<span class="token punctuation">,</span>
    <span class="token literal-property property">key2</span><span class="token operator">:</span> newState2<span class="token punctuation">,</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token comment">// 第二个参数是 state 更新完成后的回调函数</span>
</code></pre></div><h3 id="_6-react中的setstate和replacestate的区别是什么"><a href="#_6-react中的setstate和replacestate的区别是什么" class="header-anchor">#</a> 6. React中的setState和replaceState的区别是什么？</h3> <p><strong>（1）setState()</strong></p> <p>setState()用于设置状态对象，其语法如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setState</span><span class="token punctuation">(</span>object nextState<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">function</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>nextState，将要设置的新状态，该状态会和当前的state合并</li> <li>callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</li></ul> <p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p> <p><strong>（2）replaceState()</strong></p> <p>replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">replaceState</span><span class="token punctuation">(</span>object nextState<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">function</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>nextState，将要设置的新状态，该状态会替换当前的state。</li> <li>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</li></ul> <p>**总结：**setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p> <h3 id="_7-在react中组件的this-state和setstate有什么区别"><a href="#_7-在react中组件的this-state和setstate有什么区别" class="header-anchor">#</a> 7. 在React中组件的this.state和setState有什么区别？</h3> <p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p> <h3 id="_8-state-是怎么注入到组件的-从-reducer-到组件经历了什么样的过程"><a href="#_8-state-是怎么注入到组件的-从-reducer-到组件经历了什么样的过程" class="header-anchor">#</a> 8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程</h3> <p>通过connect和mapStateToProps将state注入到组件中：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> connect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-redux'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> setVisibilityFilter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@/reducers/Todo/actions'</span>
<span class="token keyword">import</span> Link <span class="token keyword">from</span> <span class="token string">'@/containers/Todo/components/Link'</span>

<span class="token keyword">const</span> <span class="token function-variable function">mapStateToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> ownProps</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">active</span><span class="token operator">:</span> ownProps<span class="token punctuation">.</span>filter <span class="token operator">===</span> state<span class="token punctuation">.</span>visibilityFilter
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">mapDispatchToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">dispatch<span class="token punctuation">,</span> ownProps</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">setFilter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">setVisibilityFilter</span><span class="token punctuation">(</span>ownProps<span class="token punctuation">.</span>filter<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">connect</span><span class="token punctuation">(</span>
    mapStateToProps<span class="token punctuation">,</span>
    mapDispatchToProps
<span class="token punctuation">)</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span>
</code></pre></div><p>上面代码中，active就是注入到Link组件中的状态。 mapStateToProps（state，ownProps）中带有两个参数，含义是∶</p> <ul><li>state-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。</li> <li>ownProps 组件通过props传入的参数。</li></ul> <p><strong>reducer 到组件经历的过程：</strong></p> <ul><li>reducer对action对象处理，更新组件状态，并将新的状态值返回store。</li> <li>通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件。</li></ul> <p><strong>高阶组件实现源码∶</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> PropTypes <span class="token keyword">from</span> <span class="token string">'prop-types'</span>

<span class="token comment">// 高阶组件 contect </span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">connect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Connect</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
        <span class="token comment">// 通过对context调用获取store</span>
        <span class="token keyword">static</span> contextTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">store</span><span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>object
        <span class="token punctuation">}</span>

        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
                <span class="token literal-property property">allProps</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 第一遍需初始化所有组件初始状态</span>
        <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span>store
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_updateProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_updateProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入_updateProps()至store里的监听事件列表</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 执行action后更新props，使组件可以更新至最新状态（类似于setState）</span>
        <span class="token function">_updateProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">.</span>store<span class="token punctuation">;</span>
            <span class="token keyword">let</span> stateProps <span class="token operator">=</span> mapStateToProps <span class="token operator">?</span>
                <span class="token function">mapStateToProps</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 防止 mapStateToProps 没有传入</span>
            <span class="token keyword">let</span> dispatchProps <span class="token operator">=</span> mapDispatchToProps <span class="token operator">?</span>
                <span class="token function">mapDispatchToProps</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>dispatch<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">{</span>
                                    <span class="token literal-property property">dispatch</span><span class="token operator">:</span> store<span class="token punctuation">.</span>dispatch
                                <span class="token punctuation">}</span> <span class="token comment">// 防止 mapDispatchToProps 没有传入</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                <span class="token literal-property property">allProps</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                    <span class="token operator">...</span>stateProps<span class="token punctuation">,</span>
                    <span class="token operator">...</span>dispatchProps<span class="token punctuation">,</span>
                    <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>allProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Connect
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_9-react组件的state和props有什么区别"><a href="#_9-react组件的state和props有什么区别" class="header-anchor">#</a> 9. React组件的state和props有什么区别？</h3> <p><strong>（1）props</strong></p> <p>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。</p> <p><strong>（2）state</strong></p> <p>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。</p> <p><strong>（3）区别</strong></p> <ul><li>props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</li> <li>props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</li> <li>state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。</li></ul> <h3 id="_10-react中的props为什么是只读的"><a href="#_10-react中的props为什么是只读的" class="header-anchor">#</a> 10. React中的props为什么是只读的？</h3> <p><code>this.props</code>是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。</p> <p>提到函数式编程就要提一个概念：纯函数。它有几个特点：</p> <ul><li>给定相同的输入，总是返回相同的输出。</li> <li>过程没有副作用。</li> <li>不依赖外部状态。</li></ul> <p><code>this.props</code>就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用</p> <h3 id="_11-在react中组件的props改变时更新组件的有哪些方法"><a href="#_11-在react中组件的props改变时更新组件的有哪些方法" class="header-anchor">#</a> 11. 在React中组件的props改变时更新组件的有哪些方法？</h3> <p>在一个组件传入的props更新时重新渲染该组件常用的方法是在<code>componentWillReceiveProps</code>中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数<code>getDerivedStateFromProps</code>来专门实现这一需求。</p> <p><strong>（1）componentWillReceiveProps（已废弃）</strong></p> <p>在react的componentWillReceiveProps(nextProps)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextProps获取新的props，对比两次props是否相同，从而更新子组件自己的state。</p> <p>这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p> <p><strong>（2）getDerivedStateFromProps（16.3引入）</strong></p> <p>这个生命周期函数是为了替代<code>componentWillReceiveProps</code>存在的，所以在需要使用<code>componentWillReceiveProps</code>时，就可以考虑使用<code>getDerivedStateFromProps</code>来进行替代。</p> <p>两者的参数是不相同的，而<code>getDerivedStateFromProps</code>是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。</p> <p>需要注意的是，<strong>如果props传入的内容不需要影响到你的state，那么就需要返回一个null</strong>，这个返回值是必须的，所以尽量将其写到函数的末尾：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>type<span class="token punctuation">}</span> <span class="token operator">=</span> nextProps<span class="token punctuation">;</span>
    <span class="token comment">// 当传入的type发生变化的时候，更新state</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            type<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 否则，对于state不进行任何操作</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_12-react中怎么检验props-验证props的目的是什么"><a href="#_12-react中怎么检验props-验证props的目的是什么" class="header-anchor">#</a> 12. React中怎么检验props？验证props的目的是什么？</h3> <p><strong>React</strong>为我们提供了<strong>PropTypes</strong>以供验证使用。当我们向<strong>Props</strong>传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> PropTypes <span class="token keyword">from</span> <span class="token string">'prop-types'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Greeting<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>string
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>当然，如果项目汇中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。</p> <h2 id="三、生命周期"><a href="#三、生命周期" class="header-anchor">#</a> 三、生命周期</h2> <h3 id="_1-react的生命周期有哪些"><a href="#_1-react的生命周期有哪些" class="header-anchor">#</a> 1. React的生命周期有哪些？</h3> <p>React 通常将组件生命周期分为三个阶段：</p> <ul><li>装载阶段（Mount），组件第一次在DOM树中被渲染的过程；</li> <li>更新过程（Update），组件状态发生变化，重新更新渲染的过程；</li> <li>卸载过程（Unmount），组件从DOM树中被移除的过程；</li></ul> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1611914193870-a5a93315-a094-40aa-959a-e3e3c58c8a96.png" alt="image.png"></p> <h4 id="_1-组件挂载阶段"><a href="#_1-组件挂载阶段" class="header-anchor">#</a> 1）组件挂载阶段</h4> <p>挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：</p> <ul><li>constructor</li> <li>getDerivedStateFromProps</li> <li>render</li> <li>componentDidMount</li></ul> <h5 id="_1-constructor"><a href="#_1-constructor" class="header-anchor">#</a> （1）constructor</h5> <p>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 <code>super(props)</code>，否则无法在构造函数中拿到this。</p> <p>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数<strong>Constructor</strong>。</p> <p>constructor中通常只做两件事：</p> <ul><li>初始化组件的 state</li> <li>给事件处理方法绑定 this</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_2-getderivedstatefromprops"><a href="#_2-getderivedstatefromprops" class="header-anchor">#</a> （2）getDerivedStateFromProps</h5> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
</code></pre></div><p>这是个静态方法，所以不能在这个函数里使用 <code>this</code>，有两个参数 <code>props</code> 和 <code>state</code>，分别指接收到的新参数和当前组件的 <code>state</code> 对象，这个函数会返回一个对象用来更新当前的 <code>state</code> 对象，如果不需要更新可以返回 <code>null</code>。</p> <p>该函数会在装载时，接收到新的 <code>props</code> 或者调用了 <code>setState</code> 和 <code>forceUpdate</code> 时被调用。如当接收到新的属性想修改 <code>state</code> ，就可以使用。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 当 props.counter 变化时，赋值给 state </span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>counter <span class="token operator">!==</span> state<span class="token punctuation">.</span>counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">counter</span><span class="token operator">:</span> props<span class="token punctuation">.</span>counter
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  
  <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h1 onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> world<span class="token operator">!</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在可以显式传入 <code>counter</code> ，但是这里有个问题，如果想要通过点击实现 <code>state.counter</code> 的增加，但这时会发现值不会发生任何变化，一直保持 <code>props</code> 传进来的值。这是由于在 React 16.4^ 的版本中 <code>setState</code> 和 <code>forceUpdate</code> 也会触发这个生命周期，所以当组件内部 <code>state</code> 变化后，就会重新走这个方法，同时会把 <code>state</code> 值赋值为 <code>props</code> 的值。因此需要多加一个字段来记录之前的 <code>props</code> 值，这样就会解决上述问题。具体如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 这里只列出需要变化的地方</span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// 增加一个 preCounter 来记录之前的 props 传来的值</span>
      <span class="token literal-property property">preCounter</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 跟 state.preCounter 进行比较</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>counter <span class="token operator">!==</span> state<span class="token punctuation">.</span>preCounter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">counter</span><span class="token operator">:</span> props<span class="token punctuation">.</span>counter<span class="token punctuation">,</span>
        <span class="token literal-property property">preCounter</span><span class="token operator">:</span> props<span class="token punctuation">.</span>counter
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h1 onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> world<span class="token operator">!</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_3-render"><a href="#_3-render" class="header-anchor">#</a> （3）render</h5> <p>render是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 <code>state</code> 和属性 <code>props</code> 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：</p> <ul><li><strong>React 元素</strong>：这里包括原生的 DOM 以及 React 组件；</li> <li><strong>数组和 Fragment（片段）</strong>：可以返回多个元素；</li> <li><strong>Portals（插槽）</strong>：可以将子元素渲染到不同的 DOM 子树种；</li> <li><strong>字符串和数字</strong>：被渲染成 DOM 中的 text 节点；</li> <li><strong>布尔值或 null</strong>：不渲染任何内容。</li></ul> <h5 id="_4-componentdidmount"><a href="#_4-componentdidmount" class="header-anchor">#</a> （4）componentDidMount()</h5> <p>componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：</p> <ul><li>执行依赖于DOM的操作；</li> <li>发送网络请求；（官方建议）</li> <li>添加订阅消息（会在componentWillUnmount取消订阅）；</li></ul> <p>如果在 <code>componentDidMount</code> 中调用 <code>setState</code> ，就会触发一次额外的渲染，多调用了一次 <code>render</code> 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 <code>constructor</code> 中初始化 <code>state</code> 对象。</p> <p>在组件装载之后，将计数数字变为1：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span>  <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentDidMount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;counter&quot;</span><span class="token operator">&gt;</span>
        <span class="token literal-property property">counter值</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-组件更新阶段"><a href="#_2-组件更新阶段" class="header-anchor">#</a> 2）组件更新阶段</h4> <p>当组件的 <code>props</code> 改变了，或组件内部调用了 <code>setState/forceUpdate</code>，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：</p> <ul><li>getDerivedStateFromProps</li> <li>shouldComponentUpdate</li> <li>render</li> <li>getSnapshotBeforeUpdate</li> <li>componentDidUpdate</li></ul> <h5 id="_1-shouldcomponentupdate"><a href="#_1-shouldcomponentupdate" class="header-anchor">#</a> （1）shouldComponentUpdate</h5> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span>
</code></pre></div><p>在说这个生命周期函数之前，来看两个问题：</p> <ul><li><strong>setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：</strong></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>number<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><strong>如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？</strong></li></ul> <p>第一个问题答案是 <strong>会</strong> ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。</p> <p>那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 <code>shouldComponentUpdate</code> 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 <code>true</code>，可以比较 <code>this.props</code> 和 <code>nextProps</code> ，<code>this.state</code> 和 <code>nextState</code> 值是否变化，来确认返回 true 或者 <code>false</code>。当返回 <code>false</code> 时，组件的更新过程停止，后续的 <code>render</code>、<code>componentDidUpdate</code> 也不会被调用。</p> <p>**注意：**添加 <code>shouldComponentUpdate</code> 方法时，不建议使用深度相等检查（如使用 <code>JSON.stringify()</code>），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。</p> <h5 id="_2-getsnapshotbeforeupdate"><a href="#_2-getsnapshotbeforeupdate" class="header-anchor">#</a> （2）getSnapshotBeforeUpdate</h5> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span>
</code></pre></div><p>这个方法在 <code>render</code> 之后，<code>componentDidUpdate</code> 之前调用，有两个参数 <code>prevProps</code> 和 <code>prevState</code>，表示更新之前的 <code>props</code> 和 <code>state</code>，这个函数必须要和 <code>componentDidUpdate</code> 一起使用，并且要有一个返回值，默认是 <code>null</code>，这个返回值作为第三个参数传给 <code>componentDidUpdate</code>。</p> <h5 id="_3-componentdidupdate"><a href="#_3-componentdidupdate" class="header-anchor">#</a> （3）componentDidUpdate</h5> <p>componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：</p> <ul><li>当组件更新后，对 DOM 进行操作；</li> <li>如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>该方法有三个参数：</p> <ul><li>prevProps: 更新前的props</li> <li>prevState: 更新前的state</li> <li>snapshot: getSnapshotBeforeUpdate()生命周期的返回值</li></ul> <h4 id="_3-组件卸载阶段"><a href="#_3-组件卸载阶段" class="header-anchor">#</a> 3）组件卸载阶段</h4> <p>卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：</p> <ul><li>清除 timer，取消网络请求或清除</li> <li>取消在 componentDidMount() 中创建的订阅等；</li></ul> <p>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 <code>setState</code>，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。</p> <h4 id="_4-错误处理阶段"><a href="#_4-错误处理阶段" class="header-anchor">#</a> 4）错误处理阶段</h4> <p>componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶</p> <ul><li>error：抛出的错误。</li> <li>info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息</li></ul> <p>React常见的生命周期如下：</p> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1606974748814-56e52599-8cda-4305-8135-eaf64d75fbb9.png" alt="image.png"></p> <p><strong>React常见生命周期的过程大致如下：</strong></p> <ul><li>挂载阶段，首先执行constructor构造方法，来创建组件</li> <li>创建完成之后，就会执行render方法，该方法会返回需要渲染的内容</li> <li>随后，React会将需要渲染的内容挂载到DOM树上</li> <li><strong>挂载完成之后就会执行****componentDidMount生命周期函数</strong></li> <li>如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数</li> <li>render函数重新执行之后，就会重新进行DOM树的挂载</li> <li><strong>挂载完成之后就会执行****componentDidUpdate生命周期函数</strong></li> <li><strong>当移除组件时，就会执行****componentWillUnmount生命周期函数</strong></li></ul> <p><strong>React主要生命周期总结：</strong></p> <ol><li><strong>getDefaultProps</strong>：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；</li> <li><strong>getInitialState</strong>：用于初始化组件的 state 值；</li> <li><strong>componentWillMount</strong>：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 <strong>React16 直接废弃了这个生命周期</strong>，足见其鸡肋程度了；</li> <li><strong>render</strong>：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；</li> <li><strong>componentDidMount</strong>：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。</li></ol> <h3 id="_2-react-废弃了哪些生命周期-为什么"><a href="#_2-react-废弃了哪些生命周期-为什么" class="header-anchor">#</a> 2. React 废弃了哪些生命周期？为什么？</h3> <p>被废弃的三个函数都是在render之前，因为fber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外的一个原因则是，React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及即将废弃的生命周期分析入手</p> <p><strong>1) componentWillMount</strong></p> <p>首先这个函数的功能完全可以使用componentDidMount和 constructor来代替，异步获取的数据的情况上面已经说明了，而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在constructor中执行，除此之外，如果在 willMount 中订阅事件，但在服务端这并不会执行 willUnMount事件，也就是说服务端会导致内存泄漏所以componentWilIMount完全可以不使用，但使用者有时候难免因为各 种各样的情况在 componentWilMount中做一些操作，那么React为了约束开发者，干脆就抛掉了这个API</p> <p><strong>2) componentWillReceiveProps</strong></p> <p>在老版本的 React 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentWilReceiveProps 中判断前后两个 props 是否相同，如果不同再将新的 props更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的时，根据传入的某个值，直接定位到某个 Tab。为了解决这些问题，React引入了第一个新的生命周期：getDerivedStateFromProps。它有以下的优点∶</p> <ul><li>getDSFP是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码</li> <li>开发者只能通过prevState而不是prevProps来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevProps为空的情况</li> <li>基于第一点，将状态变化（setState）和昂贵操作（tabChange）区分开，更加便于 render 和 commit 阶段操作或者说优化。</li></ul> <p><strong>3) componentWillUpdate</strong></p> <p>与 componentWillReceiveProps 类似，许多开发者也会在 componentWillUpdate 中根据 props 的变化去触发一些回调 。 但不论是 componentWilReceiveProps 还 是 componentWilUpdate，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 componentDidMount 类 似， componentDidUpdate 也不存在这样的问题，一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中 的 回 调 迁 移 至 componentDidUpdate 就可以解决这个问题。</p> <p>另外一种情况则是需要获取DOM元素状态，但是由于在fber中，render可打断，可能在wilMount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用第二个新增的生命函数的解决 getSnapshotBeforeUpdate(prevProps, prevState)</p> <p><strong>4) getSnapshotBeforeUpdate(prevProps, prevState)</strong></p> <p>返回的值作为componentDidUpdate的第三个参数。与willMount不同的是，getSnapshotBeforeUpdate会在最终确定的render执行之前执行，也就是能保证其获取到的元素状态与didUpdate中获取到的元素状态相同。官方参考代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">ScrollingList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 我们是否在 list 中添加新的 items ？</span>
    <span class="token comment">// 捕获滚动位置以便我们稍后调整滚动位置。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevProps<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
      <span class="token keyword">return</span> list<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> list<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span>
    <span class="token comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span>
    <span class="token comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>snapshot <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
      list<span class="token punctuation">.</span>scrollTop <span class="token operator">=</span> list<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> snapshot<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token comment">/* ...contents... */</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-react-16-x-中-props-改变后在哪个生命周期中处理"><a href="#_3-react-16-x-中-props-改变后在哪个生命周期中处理" class="header-anchor">#</a> 3. React 16.X 中 props 改变后在哪个生命周期中处理</h3> <p><strong>在getDerivedStateFromProps中进行处理。</strong></p> <p>这个生命周期函数是为了替代<code>componentWillReceiveProps</code>存在的，所以在需要使用<code>componentWillReceiveProps</code>时，就可以考虑使用<code>getDerivedStateFromProps</code>来进行替代。</p> <p>两者的参数是不相同的，而<code>getDerivedStateFromProps</code>是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。</p> <p>需要注意的是，<strong>如果props传入的内容不需要影响到你的state，那么就需要返回一个null</strong>，这个返回值是必须的，所以尽量将其写到函数的末尾：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>type<span class="token punctuation">}</span> <span class="token operator">=</span> nextProps<span class="token punctuation">;</span>
    <span class="token comment">// 当传入的type发生变化的时候，更新state</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            type<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 否则，对于state不进行任何操作</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_4-react-性能优化在哪个生命周期-它优化的原理是什么"><a href="#_4-react-性能优化在哪个生命周期-它优化的原理是什么" class="header-anchor">#</a> 4. React 性能优化在哪个生命周期？它优化的原理是什么？</h3> <p>react的父级组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件render的执行会影响性能，这时就可以使用shouldComponentUpdate来解决这个问题。</p> <p>使用方法如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nexrProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>num <span class="token operator">===</span> nexrProps<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>shouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。</p> <p>需要注意，在进行新旧对比的时候，是**浅对比，**也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。</p> <p>面对这个问题，可以使用如下方法进行解决：</p> <p>（1）使用setState改变数据之前，先采用ES6中assgin进行拷贝，但是assgin只深拷贝的数据的第一层，所以说不是最完美的解决办法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> o2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
    o2<span class="token punctuation">.</span>student<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token string">'00000'</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">obj</span><span class="token operator">:</span> o2<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>（2）使用JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为undefined和函数时就会错。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> o2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
    o2<span class="token punctuation">.</span>student<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token string">'00000'</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">obj</span><span class="token operator">:</span> o2<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_5-state-和-props-触发更新的生命周期分别有什么区别"><a href="#_5-state-和-props-触发更新的生命周期分别有什么区别" class="header-anchor">#</a> 5. state 和 props 触发更新的生命周期分别有什么区别？</h3> <p><strong>state 更新流程：</strong></p> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1616079696588-fe9625ce-a23f-42ef-ae52-247b29b5ee3c.png" alt="image"></p> <p>这个过程当中涉及的函数：</p> <ol><li>shouldComponentUpdate: 当组件的 state 或 props 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：nextProps, nextState——它们分别代表传入的新 props 和新的 state 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 re-render（重渲染）的必要了。如果该函数的返回值为 false，则生命周期终止，反之继续；</li></ol> <blockquote><p>注意：此方法仅作为<strong>性能优化的方式</strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。应该<strong>考虑使用内置的 PureComponent 组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code></p></blockquote> <ol><li>componentWillUpdate：当组件的 state 或 props 发生改变时，会在渲染之前调用 componentWillUpdate。componentWillUpdate <strong>是 React16 废弃的三个生命周期之一</strong>。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 DOM 信息等等），现在我们完全可以在 React16 的 getSnapshotBeforeUpdate 中去做这些事；</li> <li>componentDidUpdate：componentDidUpdate() 会在UI更新后会被立即调用。它接收 prevProps（上一次的 props 值）作为入参，也就是说在此处我们仍然可以进行 props 值对比（再次说明 componentWillUpdate 确实鸡肋哈）。</li></ol> <p><strong>props 更新流程：</strong></p> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1616079696446-71709f4d-1b94-4405-9538-5167ed5e4f2a.png" alt="image"></p> <p>相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，需要知道这些事情：</p> <ul><li>componentWillReceiveProps：它在Component接受到新的 props 时被触发。componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。<strong>该生命周期是 React16 废弃掉的三个生命周期之一</strong>。在它被废弃前，可以用它来比较 this.props 和 nextProps 来重新setState。在 React16 中，用一个类似的新生命周期 getDerivedStateFromProps 来代替它。</li></ul> <h3 id="_6-react中发起网络请求应该在哪个生命周期中进行-为什么"><a href="#_6-react中发起网络请求应该在哪个生命周期中进行-为什么" class="header-anchor">#</a> 6. React中发起网络请求应该在哪个生命周期中进行？为什么？</h3> <p>对于异步请求，最好放在componentDidMount中去操作，对于同步的状态改变，可以放在componentWillMount中，一般用的比较少。</p> <p>如果认为在componentWillMount里发起请求能提早获得结果，这种想法其实是错误的，通常componentWillMount比componentDidMount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。</p> <p>**react的生命周期：**constructor() -&gt; componentWillMount() -&gt; render() -&gt; componentDidMount()</p> <p>上面这些方法的调用是有次序的，由上而下依次调用。</p> <ul><li>constructor被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。</li> <li>componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重新render，所以它一般不会用来作加载数据之用。</li> <li>componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。</li></ul> <p>总结：</p> <ul><li>跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题，componentWillMount同样也会render两次。</li> <li>在componentWillMount中fetch data，数据一定在render后才能到达，如果忘记了设置初始状态，用户体验不好。</li> <li>react16.0以后，componentWillMount可能会被执行多次。</li></ul> <h3 id="_7-react-16中新生命周期有哪些"><a href="#_7-react-16中新生命周期有哪些" class="header-anchor">#</a> 7. React 16中新生命周期有哪些</h3> <p>关于 React16 开始应用的新生命周期：</p> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1616079836302-3fdd2b2a-6d54-4a7e-92bd-86a6aa27aea6.png" alt="image"></p> <p>可以看出，React16 自上而下地对生命周期做了另一种维度的解读：</p> <ul><li><strong>Render 阶段</strong>：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构（我们后面会重点讲解）是有关的；</li> <li><strong>Pre-commit阶段</strong>：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了；</li> <li><strong>Commit 阶段</strong>：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。</li></ul> <p>与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：</p> <ul><li><p>挂载过程：</p></li> <li><ul><li><strong>constructor</strong></li> <li><strong>getDerivedStateFromProps</strong></li> <li><strong>render</strong></li> <li><strong>componentDidMount</strong></li></ul></li> <li><p>更新过程：</p></li> <li><ul><li><strong>getDerivedStateFromProps</strong></li> <li><strong>shouldComponentUpdate</strong></li> <li><strong>render</strong></li> <li><strong>getSnapshotBeforeUpdate</strong></li> <li><strong>componentDidUpdate</strong></li></ul></li> <li><p>卸载过程：</p></li> <li><ul><li><strong>componentWillUnmount</strong></li></ul></li></ul> <h3 id="_1-react组件命名推荐的方式是哪个"><a href="#_1-react组件命名推荐的方式是哪个" class="header-anchor">#</a> 1. React组件命名推荐的方式是哪个？</h3> <p>通过引用而不是使用来命名组件displayName。</p> <p>使用displayName命名组件：</p> <div class="language- extra-class"><pre class="language-text"><code>export default React.createClass({
  displayName: 'TodoApp',
  // ...
})
</code></pre></div><p>React推荐的方法：</p> <div class="language- extra-class"><pre class="language-text"><code>export default class TodoApp extends React.Component {
  // ...
}
</code></pre></div><h3 id="_2-react-最新版本解决了什么问题-增加了哪些东西"><a href="#_2-react-最新版本解决了什么问题-增加了哪些东西" class="header-anchor">#</a> 2. react 最新版本解决了什么问题，增加了哪些东西</h3> <p>React 16.x的三大新特性 Time Slicing、Suspense、 hooks</p> <ul><li><strong>Time Slicing（解决CPU速度问题</strong>）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能</li> <li>**Suspense （解决网络IO问题）**和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式</li> <li>提供了一个<strong>内置函数componentDidCatch</strong>，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。</li></ul> <p><strong>（1）React16.8</strong></p> <p>加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：</p> <ul><li>在组件间复用状态逻辑很难</li> <li>复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。</li> <li>class组件的this指向问题</li> <li>难以记忆的生命周期</li></ul> <p>hooks很好的解决了上述问题，hooks提供了很多方法</p> <ul><li>useState 返回有状态值，以及更新这个状态值的函数</li> <li>useEffect 接受包含命令式，可能有副作用代码的函数。</li> <li>useContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值，</li> <li>useReducer useState 的替代方案。接受类型为 （state，action）=&gt; newState的reducer，并返回与dispatch方法配对的当前状态。</li> <li>useCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。</li> <li>useImperativeMethods 自定义使用ref时公开给父组件的实例值</li> <li>useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发</li> <li>useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染</li></ul> <p><strong>（2）React16.9</strong></p> <ul><li>重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出</li> <li>废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。</li> <li>废弃&quot;Factory&quot;组件。 工厂组件会导致 React 变大且变慢。</li> <li>act（）也支持异步函数，并且你可以在调用它时使用 await。</li> <li>使用 &lt;React.ProfiLer&gt; 进行性能评估。在较大的应用中追踪性能回归可能会很方便</li></ul> <p><strong>（3）React16.13.0</strong></p> <ul><li>支持在渲染期间调用setState，但仅适用于同一组件</li> <li>可检测冲突的样式规则并记录警告</li> <li>废弃 unstable_createPortal，使用CreatePortal</li> <li>将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。</li></ul> <h3 id="_3-react-实现一个全局的-dialog"><a href="#_3-react-实现一个全局的-dialog" class="header-anchor">#</a> 3. react 实现一个全局的 dialog</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> is<span class="token punctuation">,</span> fromJS <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'immutable'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactCSSTransitionGroup <span class="token keyword">from</span> <span class="token string">'react-addons-css-transition-group'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'./dialog.css'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> defaultState <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">alertStatus</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">alertTip</span><span class="token operator">:</span><span class="token string">&quot;提示&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">closeDialog</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">childs</span><span class="token operator">:</span><span class="token string">''</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dialog</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>defaultState
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// css动画组件设置为目标组件</span>
  <span class="token function-variable function">FirstChild</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> childrenArray <span class="token operator">=</span> React<span class="token punctuation">.</span>Children<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> childrenArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//打开弹窗</span>
  <span class="token function-variable function">open</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    options <span class="token operator">=</span> options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    options<span class="token punctuation">.</span>alertStatus <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> props <span class="token operator">=</span> options<span class="token punctuation">.</span>props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> childs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renderChildren</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span>options<span class="token punctuation">.</span>childrens<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>childs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token operator">...</span>defaultState<span class="token punctuation">,</span>
      <span class="token operator">...</span>options<span class="token punctuation">,</span>
      childs
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//关闭弹窗</span>
  <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">closeDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token operator">...</span>defaultState
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">renderChildren</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span>childrens</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//遍历所有子组件</span>
    <span class="token keyword">var</span> childs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    childrens <span class="token operator">=</span> childrens <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> ps <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span>props<span class="token punctuation">,</span>  <span class="token comment">//给子组件绑定props</span>
        <span class="token literal-property property">_close</span><span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>close  <span class="token comment">//给子组件也绑定一个关闭弹窗的事件    </span>
       <span class="token punctuation">}</span><span class="token punctuation">;</span>
    childrens<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">currentItem<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        childs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>
            currentItem<span class="token punctuation">,</span>
            <span class="token punctuation">{</span>
                <span class="token operator">...</span>ps<span class="token punctuation">,</span>
                <span class="token literal-property property">key</span><span class="token operator">:</span>index
            <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> childs<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token function">fromJS</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fromJS</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token function">fromJS</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fromJS</span><span class="token punctuation">(</span>nextState<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
   
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ReactCSSTransitionGroup
        component<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>FirstChild<span class="token punctuation">}</span>
        transitionName<span class="token operator">=</span><span class="token string">'hide'</span>
        transitionEnterTimeout<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">300</span><span class="token punctuation">}</span>
        transitionLeaveTimeout<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">300</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;dialog-con&quot;</span> style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>alertStatus<span class="token operator">?</span> <span class="token punctuation">{</span><span class="token literal-property property">display</span><span class="token operator">:</span><span class="token string">'block'</span><span class="token punctuation">}</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">display</span><span class="token operator">:</span><span class="token string">'none'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
            <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>childs<span class="token punctuation">}</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ReactCSSTransitionGroup<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token punctuation">{</span>
   
<span class="token punctuation">}</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> Box <span class="token operator">=</span> ReactD
</code></pre></div><p>子类：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//子类jsx</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">date</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function-variable function">showValue</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>showValue <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">showValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;Child&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;content&quot;</span><span class="token operator">&gt;</span>
           Child
           <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>showValue<span class="token punctuation">}</span><span class="token operator">&gt;</span>调用父的方法<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> Child<span class="token punctuation">;</span>
</code></pre></div><p>css：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.dialog-con</span><span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_4-react-数据持久化有什么实践吗"><a href="#_4-react-数据持久化有什么实践吗" class="header-anchor">#</a> 4. React 数据持久化有什么实践吗？</h3> <p>封装数据持久化组件：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>】<span class="token keyword">let</span> storage<span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token comment">// 增加</span>
    <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 获取</span>
    <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 删除</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> Storage<span class="token punctuation">;</span>
</code></pre></div><p>在React项目中，通过redux存储全局数据时，会有一个问题，如果用户刷新了网页，那么通过redux存储的全局数据就会被全部清空，比如登录信息等。这时就会有全局数据持久化存储的需求。首先想到的就是localStorage，localStorage是没有时间限制的数据存储，可以通过它来实现数据的持久化存储。</p> <p>但是在已经使用redux来管理和存储全局数据的基础上，再去使用localStorage来读写数据，这样不仅是工作量巨大，还容易出错。那么有没有结合redux来达到持久数据存储功能的框架呢？当然，它就是<strong>redux-persist</strong>。redux-persist会将redux的store中的数据缓存到浏览器的localStorage中。其使用步骤如下：</p> <p><strong>（1）首先要安装redux-persist：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>npm i redux-persist
</code></pre></div><p><strong>（2）对于reducer和action的处理不变，只需修改store的生成代码，修改如下：</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>createStore<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token keyword">import</span> reducers <span class="token keyword">from</span> <span class="token string">'../reducers/index'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>persistStore<span class="token punctuation">,</span> persistReducer<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux-persist'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> storage <span class="token keyword">from</span> <span class="token string">'redux-persist/lib/storage'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> autoMergeLevel2 <span class="token keyword">from</span> <span class="token string">'redux-persist/lib/stateReconciler/autoMergeLevel2'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> persistConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">storage</span><span class="token operator">:</span> storage<span class="token punctuation">,</span>
    <span class="token literal-property property">stateReconciler</span><span class="token operator">:</span> autoMergeLevel2 <span class="token comment">// 查看 'Merge Process' 部分的具体情况</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> myPersistReducer <span class="token operator">=</span> <span class="token function">persistReducer</span><span class="token punctuation">(</span>persistConfig<span class="token punctuation">,</span> reducers<span class="token punctuation">)</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>myPersistReducer<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> persistor <span class="token operator">=</span> <span class="token function">persistStore</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> store
</code></pre></div><p><strong>（3）在index.js中，将PersistGate标签作为网页内容的父标签：</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>Provider<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-redux'</span>
<span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./redux/store/store'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>persistor<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./redux/store/store'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>PersistGate<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux-persist/lib/integration/react'</span><span class="token punctuation">;</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Provider store<span class="token operator">=</span><span class="token punctuation">{</span>store<span class="token punctuation">}</span><span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>PersistGate loading<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">null</span><span class="token punctuation">}</span> persistor<span class="token operator">=</span><span class="token punctuation">{</span>persistor<span class="token punctuation">}</span><span class="token operator">&gt;</span>
                <span class="token punctuation">{</span><span class="token comment">/*网页内容*/</span><span class="token punctuation">}</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>PersistGate<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>Provider<span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这就完成了通过redux-persist实现React持久化本地数据存储的简单应用。</p> <h3 id="_5-对-react-和-vue-的理解-它们的异同"><a href="#_5-对-react-和-vue-的理解-它们的异同" class="header-anchor">#</a> 5. 对 React 和 Vue 的理解，它们的异同</h3> <p><strong>相似之处：</strong></p> <ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</li> <li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。</li> <li>都使用了Virtual DOM（虚拟DOM）提高重绘性能</li> <li>都有props的概念，允许组件间的数据传递</li> <li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性</li></ul> <p><strong>不同之处：</strong></p> <p><strong>1）数据流</strong></p> <p>Vue默认支持数据双向绑定，而React一直提倡单向数据流</p> <p><strong>2）虚拟DOM</strong></p> <p>Vue2.x开始引入&quot;Virtual DOM&quot;，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p> <ul><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li> <li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul> <p><strong>3）组件化</strong></p> <p>React与Vue最大的不同是模板的编写。</p> <ul><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li> <li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ul> <p>具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。</p> <p><strong>4）监听数据变化的实现原理不同</strong></p> <ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li> <li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ul> <p><strong>5）高阶组件</strong></p> <p>react可以通过高阶组件（Higher Order Components-- HOC）来扩展，而vue需要通过mixins来扩展。</p> <p>原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。</p> <p><strong>6）构建工具</strong></p> <p>两者都有自己的构建工具</p> <ul><li>React ==&gt; Create React APP</li> <li>Vue ==&gt; vue-cli</li></ul> <p><strong>7）跨平台</strong></p> <ul><li>React ==&gt; React Native</li> <li>Vue ==&gt; Weex</li></ul> <h3 id="_6-可以使用typescript写react应用吗-怎么操作"><a href="#_6-可以使用typescript写react应用吗-怎么操作" class="header-anchor">#</a> 6. 可以使用TypeScript写React应用吗？怎么操作？</h3> <p><strong>（1）如果还未创建 Create React App 项目</strong></p> <ul><li>直接创建一个具有 typescript 的 Create React App 项目：</li></ul> <div class="language- extra-class"><pre class="language-text"><code> npx create-react-app demo --typescript
</code></pre></div><p><strong>（2）如果已经创建了 Create React App 项目，需要将 typescript 引入到已有项目中</strong></p> <ul><li>通过命令将 typescript 引入项目：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install --save typescript @types/node @types/react @types/react-dom @types/jest
</code></pre></div><ul><li>将项目中任何 后缀名为 ‘.js’ 的 JavaScript 文件重命名为 TypeScript 文件即后缀名为 ‘.tsx’（例如 src/index.js 重命名为 src/index.tsx ）</li></ul> <h3 id="_7-react-设计思路-它的理念是什么"><a href="#_7-react-设计思路-它的理念是什么" class="header-anchor">#</a> 7. React 设计思路，它的理念是什么？</h3> <p><strong>（1）编写简单直观的代码</strong></p> <p>React最大的价值不是高性能的虚拟DOM、封装的事件机制、服务器端渲染，而是声明式的直观的编码方式。react文档第一条就是声明式，React 使创建交互式 UI 变得轻而易举。为应用的每一个状态设计简洁的视图，当数据改变时 React 能有效地更新并正确地渲染组件。 以声明式编写 UI，可以让代码更加可靠，且方便调试。</p> <p><strong>（2）简化可复用的组件</strong></p> <p>React框架里面使用了简化的组件模型，但更彻底地使用了组件化的概念。React将整个UI上的每一个功能模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成更大的组件。React的组件具有如下的特性∶</p> <ul><li><p>可组合：简单组件可以组合为复杂的组件</p></li> <li><p>可重用：每个组件都是独立的，可以被多个组件使用</p></li> <li><p>可维护：和组件相关的逻辑和UI都封装在了组件的内部，方便维护</p></li> <li><p>可测试：因为组件的独立性，测试组件就变得方便很多。</p></li></ul> <p><strong>（3) Virtual DOM</strong></p> <p>真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新。 DOM 操作非常昂贵。在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难 以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM，每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能。</p> <p><strong>（4）函数式编程</strong></p> <p>React 把过去不断重复构建 UI 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 UI 界面。React 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。</p> <p><strong>（5）一次学习，随处编写</strong></p> <p>无论现在正在使用什么技术栈，都可以随时引入 React来开发新特性，而不需要重写现有代码。</p> <p>React 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。因为 React 组件可以映射为对应的原生控件。在输出的时候，是输出 Web DOM，还是 Android 控件，还是 iOS 控件，就由平台本身决定了。所以，react很方便和其他平台集成</p> <h3 id="_8-react中props-children和react-children的区别"><a href="#_8-react中props-children和react-children的区别" class="header-anchor">#</a> 8. React中props.children和React.Children的区别</h3> <p>在React中，当涉及组件嵌套，在父组件中使用<code>props.children</code>把所有子组件显示出来。如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ParentComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
            <span class="token punctuation">{</span>props<span class="token punctuation">.</span>children<span class="token punctuation">}</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果想把父组件中的属性传给所有的子组件，需要使用<code>React.Children</code>方法。</p> <p>比如，把几个Radio组合起来，合成一个RadioGroup，这就要求所有的Radio具有同样的name属性值。可以这样：把Radio看做子组件，RadioGroup看做父组件，name的属性值在RadioGroup这个父组件中设置。</p> <p>首先是子组件：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//子组件</span>
<span class="token keyword">function</span> <span class="token function">RadioOption</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>label<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;radio&quot;</span> value<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">}</span> name<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>props<span class="token punctuation">.</span>label<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后是父组件，不仅需要把它所有的子组件显示出来，还需要为每个子组件赋上name属性和值：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//父组件用,props是指父组件的props</span>
<span class="token keyword">function</span> <span class="token function">renderChildren</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
  <span class="token comment">//遍历所有子组件</span>
  <span class="token keyword">return</span> React<span class="token punctuation">.</span>Children<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>children<span class="token punctuation">,</span> <span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>type <span class="token operator">===</span> RadioOption<span class="token punctuation">)</span>
      <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">cloneElement</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token comment">//把父组件的props.name赋值给每个子组件</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> props<span class="token punctuation">.</span>name
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span>
      <span class="token keyword">return</span> child
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">//父组件</span>
<span class="token keyword">function</span> <span class="token function">RadioGroup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span><span class="token function">renderChildren</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>RadioGroup name<span class="token operator">=</span><span class="token string">&quot;hello&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>RadioOption label<span class="token operator">=</span><span class="token string">&quot;选项一&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;1&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>RadioOption label<span class="token operator">=</span><span class="token string">&quot;选项二&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;2&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>RadioOption label<span class="token operator">=</span><span class="token string">&quot;选项三&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;3&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>RadioGroup<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><p>以上，<code>React.Children.map</code>让我们对父组件的所有子组件又更灵活的控制。</p> <h3 id="_9-react的状态提升是什么-使用场景有哪些"><a href="#_9-react的状态提升是什么-使用场景有哪些" class="header-anchor">#</a> 9. React的状态提升是什么？使用场景有哪些？</h3> <p>React的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。</p> <p>概括来说就是<strong>将多个组件需要共享的状态提升到它们最近的父组件上</strong>，<strong>在父组件上改变这个状态然后通过props分发给子组件。</strong></p> <p>一个简单的例子，父组件中有两个input子组件，如果想在第一个输入框输入数据，来改变第二个输入框的值，这就需要用到状态提升。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">Value1</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
            <span class="token literal-property property">Value2</span><span class="token operator">:</span> <span class="token string">''</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">value1Change</span><span class="token punctuation">(</span><span class="token parameter">aa</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token literal-property property">Value1</span><span class="token operator">:</span> aa
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">value2Change</span><span class="token punctuation">(</span><span class="token parameter">bb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token literal-property property">Value2</span><span class="token operator">:</span> bb
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token literal-property property">padding</span><span class="token operator">:</span> <span class="token string">&quot;100px&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>Child1 value1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>Value1<span class="token punctuation">}</span> onvalue1Change<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">value1Change</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>Child2 value2<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>Value1<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child1</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">changeValue</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onvalue1Change</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>input value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>Value1<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">changeValue</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child2</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>input value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>value2<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Father <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><h3 id="_10-react中constructor和getinitialstate的区别"><a href="#_10-react中constructor和getinitialstate的区别" class="header-anchor">#</a> 10. React中constructor和getInitialState的区别?</h3> <p>两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。</p> <p>getInitialState是ES5中的方法，如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token constant">APP</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">creatClass</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">getInitialState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> 
        <span class="token literal-property property">userName</span><span class="token operator">:</span> <span class="token string">'hi'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">userId</span><span class="token operator">:</span> <span class="token number">0</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
　<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>React在ES6的实现中去掉了getInitialState这个hook函数，规定state在constructor中实现，如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Class App <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="_11-react的严格模式如何使用-有什么用处"><a href="#_11-react的严格模式如何使用-有什么用处" class="header-anchor">#</a> 11. React的严格模式如何使用，有什么用处？</h3> <p><code>StrictMode</code> 是一个用来突出显示应用程序中潜在问题的工具。与 <code>Fragment</code> 一样，<code>StrictMode</code> 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。</p> <p>可以为应用程序的任何部分启用严格模式。例如：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">ExampleApplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Header <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>StrictMode<span class="token operator">&gt;</span>        
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>ComponentOne <span class="token operator">/</span><span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>ComponentTwo <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>StrictMode<span class="token operator">&gt;</span>      
      <span class="token operator">&lt;</span>Footer <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上述的示例中，<em>不</em>会对 <code>Header</code> 和 <code>Footer</code> 组件运行严格模式检查。但是，<code>ComponentOne</code> 和 <code>ComponentTwo</code> 以及它们的所有后代元素都将进行检查。</p> <p><code>StrictMode</code> 目前有助于：</p> <ul><li>识别不安全的生命周期</li> <li>关于使用过时字符串 ref API 的警告</li> <li>关于使用废弃的 findDOMNode 方法的警告</li> <li>检测意外的副作用</li> <li>检测过时的 context API</li></ul> <h3 id="_12-在react中遍历的方法有哪些"><a href="#_12-在react中遍历的方法有哪些" class="header-anchor">#</a> 12. 在React中遍历的方法有哪些？</h3> <p><strong>（1）遍历数组：map &amp;&amp; forEach</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>
          arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>
          arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>（2）遍历对象：map &amp;&amp; for in</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
      <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">3</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>
          <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> domArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">const</span> value <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
                domArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>key<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token punctuation">)</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> domArr<span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Object.entries() 把对象转换成数组</span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
      <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">3</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>
          Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span><span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>   <span class="token comment">// item是一个数组，把item解构，写法是[key, value]</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>key<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span> 
        <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_13-在react中页面重新加载时怎样保留数据"><a href="#_13-在react中页面重新加载时怎样保留数据" class="header-anchor">#</a> 13. 在React中页面重新加载时怎样保留数据？</h3> <p>这个问题就设计到了**数据持久化，**主要的实现方式有以下几种：</p> <ul><li>**Redux：**将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；</li> <li>**data.js：**使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；</li> <li>**sessionStorge：**在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据</li> <li>**history API：**History API 的 <code>pushState</code> 函数可以给历史记录关联一个任意的可序列化 <code>state</code>，所以可以在路由 <code>push</code> 的时候将当前页面的一些信息存到 <code>state</code> 中，下次返回到这个页面的时候就能从 <code>state</code> 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。</li></ul> <h3 id="_14-同时引用这三个库react-js、react-dom-js和babel-js它们都有什么作用"><a href="#_14-同时引用这三个库react-js、react-dom-js和babel-js它们都有什么作用" class="header-anchor">#</a> 14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？</h3> <ul><li>react：包含react所必须的核心代码</li> <li>react-dom：react渲染在不同平台所需要的核心代码</li> <li>babel：将jsx转换成React代码的工具</li></ul> <h3 id="_15-react必须使用jsx吗"><a href="#_15-react必须使用jsx吗" class="header-anchor">#</a> 15. React必须使用JSX吗？</h3> <p>React 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。</p> <p>每个 JSX 元素只是调用 <code>React.createElement(component, props, ...children)</code> 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。</p> <p>例如，用 JSX 编写的代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Hello <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>toWhat<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Hello toWhat<span class="token operator">=</span><span class="token string">&quot;World&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以编写为不使用 JSX 的代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>toWhat<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">toWhat</span><span class="token operator">:</span> <span class="token string">'World'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_16-为什么使用jsx的组件中没有看到使用react却需要引入react"><a href="#_16-为什么使用jsx的组件中没有看到使用react却需要引入react" class="header-anchor">#</a> 16. 为什么使用jsx的组件中没有看到使用react却需要引入react？</h3> <p>本质上来说JSX是<code>React.createElement(component, props, ...children)</code>方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， <code>babel</code> 会把组件转换为 <code>CreateElement</code> 形式。在React 17之后，就不再需要引入，因为 <code>babel</code> 已经可以帮我们自动引入react。</p> <h3 id="_17-在react中怎么使用async-await"><a href="#_17-在react中怎么使用async-await" class="header-anchor">#</a> 17. 在React中怎么使用async/await？</h3> <p>async/await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 <strong>regeneratorRuntime is not defined</strong> 的异常错误。那么我们就需要引入babel，并在babel中配置使用async/await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。</p> <h3 id="_18-react-children-map和js的map有什么区别"><a href="#_18-react-children-map和js的map有什么区别" class="header-anchor">#</a> 18. React.Children.map和js的map有什么区别？</h3> <p>JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。</p> <h3 id="_19-对react-ssr的理解"><a href="#_19-对react-ssr的理解" class="header-anchor">#</a> 19. 对React SSR的理解</h3> <p>服务端渲染是数据与模版组成的html，即 HTML = 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记&quot;混合&quot;为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;</p> <p><strong>SSR的优势：</strong></p> <ul><li>对SEO友好</li> <li>所有的模版、图片等资源都存在服务器端</li> <li>一个html返回所有数据</li> <li>减少HTTP请求</li> <li>响应快、用户体验好、首屏渲染快</li></ul> <p><strong>1）更利于SEO</strong></p> <p>不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了React或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。</p> <p><strong>2）更利于首屏渲染</strong></p> <p>首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。</p> <p><strong>SSR的局限：</strong></p> <p><strong>1）服务端压力较大</strong></p> <p>本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;</p> <p><strong>2）开发条件受限</strong></p> <p>在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;</p> <p><strong>3）学习成本相对较高</strong></p> <p>除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。</p> <p><strong>时间耗时比较：</strong></p> <p><strong>1）数据请求</strong></p> <p>由服务端请求首屏数据，而不是客户端请求首屏数据，这是&quot;快&quot;的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差</p> <ul><li>客户端数据请求</li></ul> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1612599697115-b749fd70-9747-4f83-a836-72f46f5e91de.jpeg" alt="51612599334_.pic.jpg"></p> <ul><li>服务端数据请求</li></ul> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1612599745397-099cca87-5c01-4c45-94ad-318b054b7a01.jpeg" alt="61612599340_.pic.jpg"></p> <p><strong>2）html渲染</strong></p> <p>服务端渲染是先向后端服务器请求数据，然后生成完整首屏 html返回给浏览器；而客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待js代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。</p> <ul><li>非ssr html渲染</li></ul> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1612599842432-0b804ffa-177b-43c8-a973-d633917b784b.jpeg" alt="31612599269_.pic.jpg"></p> <ul><li>ssr html渲染</li></ul> <p><img src="https://xiumubai.oss-cn-beijing.aliyuncs.com/blog/1612599902197-a00e3b91-390f-47b7-856f-b1f2d5c782f7.jpeg" alt="41612599275_.pic.jpg"></p> <h3 id="_20-为什么-react-要用-jsx"><a href="#_20-为什么-react-要用-jsx" class="header-anchor">#</a> 20. 为什么 React 要用 JSX？</h3> <p>JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。</p> <p>其实 React 本身并不强制使用 JSX。在没有 JSX 的时候，React 实现一个组件依赖于使用 React.createElement 函数。代码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>
        <span class="token string">'div'</span><span class="token punctuation">,</span>
        <span class="token keyword">null</span><span class="token punctuation">,</span> 
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>toWhat<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">toWhat</span><span class="token operator">:</span> <span class="token string">'World'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而 JSX 更像是一种语法糖，通过类似 XML 的描述方式，描写函数对象。在采用 JSX 之后，这段代码会这样写：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Hello <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>toWhat<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Hello toWhat<span class="token operator">=</span><span class="token string">&quot;World&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过对比，可以清晰地发现，代码变得更为简洁，而且代码结构层次更为清晰。</p> <p>因为 React 需要将组件转化为虚拟 DOM 树，所以在编写代码时，实际上是在手写一棵结构树。而<strong>XML 在树结构的描述上天生具有可读性强的优势。</strong></p> <p>但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。</p> <p><strong>总结：</strong></p> <p>JSX 是一个 JavaScript 的语法扩展，结构类似 XML。JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。</p> <p>React 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。</p> <h3 id="_21-hoc相比-mixins-有什么优点"><a href="#_21-hoc相比-mixins-有什么优点" class="header-anchor">#</a> 21. HOC相比 mixins 有什么优点？</h3> <p>HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：</p> <ul><li>隐含了一些依赖，比如我在组件中写了某个 <code>state</code> 并且在 <code>mixin</code> 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 <code>mixin</code> 中查找依赖</li> <li>多个 <code>mixin</code> 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。。</li> <li>雪球效应，虽然我一个组件还是使用着同一个 <code>mixin</code>，但是一个 <code>mixin</code> 会被多个组件使用，可能会存在需求使得 <code>mixin</code> 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本</li></ul> <p>HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）。</p> <h3 id="_22-react-中的高阶组件运用了什么设计模式"><a href="#_22-react-中的高阶组件运用了什么设计模式" class="header-anchor">#</a> 22. React 中的高阶组件运用了什么设计模式？</h3> <p>使用了装饰模式，高阶组件的运用：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">withWindowWidth</span><span class="token punctuation">(</span><span class="token parameter">BaseComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">DerivedClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">windowWidth</span><span class="token operator">:</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    <span class="token function-variable function">onResize</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">windowWidth</span><span class="token operator">:</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'resize'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onResize<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'resize'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onResize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>BaseComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> DerivedClass<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">MyComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Window width is<span class="token operator">:</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>windowWidth<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withWindowWidth</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：</p> <div class="language- extra-class"><pre class="language-text"><code>@testable
   class MyTestableClass {
}
</code></pre></div></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xiumubai/blog/edit/master/docs/02.前端面试攻略/15.offer收割机之React篇(上).md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/03/30, 12:10:12</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/832bf4/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">14 offer收割机之vue项目性能优化</div></a> <a href="/pages/cb0032/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">16 offer收割机之React篇(中)</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/832bf4/" class="prev">14 offer收割机之vue项目性能优化</a></span> <span class="next"><a href="/pages/cb0032/">16 offer收割机之React篇(中)</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/c852b9/"><div>
            用slidev写PPT
            <!----></div></a> <span class="date">04-10</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/deb61a/"><div>
            04.用reveal-md写PPT
            <!----></div></a> <span class="date">04-09</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/9ee271/"><div>
            mac使用技巧
            <!----></div></a> <span class="date">03-30</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/xiumubai" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://juejin.cn/user/430664288573789" title="掘金" target="_blank" class="iconfont icon-juejin"></a><a href="https://www.yuque.com/xiumubai" title="语雀" target="_blank" class="iconfont icon-yuque"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2021-2022
    <span>朽木学社版权所有 | <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">京ICP备2022002793号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.fb1f9387.js" defer></script><script src="/assets/js/2.3389238a.js" defer></script><script src="/assets/js/149.ed205a73.js" defer></script>
  </body>
</html>
